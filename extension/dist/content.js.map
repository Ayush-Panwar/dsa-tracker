{"version":3,"file":"content.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://extension/./lib/error-analyzer.ts","webpack://extension/./lib/leetcode-api.ts","webpack://extension/webpack/bootstrap","webpack://extension/webpack/runtime/define property getters","webpack://extension/webpack/runtime/hasOwnProperty shorthand","webpack://extension/webpack/runtime/make namespace object","webpack://extension/./content/content.ts"],"sourcesContent":["/**\n * Error Analysis Module for DSA Tracker\n * Analyzes code errors and classifies them into patterns to help users learn from mistakes\n */\n// Error types classification\nexport var ErrorType;\n(function (ErrorType) {\n    ErrorType[\"SYNTAX\"] = \"syntax\";\n    ErrorType[\"RUNTIME\"] = \"runtime\";\n    ErrorType[\"LOGICAL\"] = \"logical\";\n    ErrorType[\"TIME_LIMIT\"] = \"time_limit\";\n    ErrorType[\"MEMORY_LIMIT\"] = \"memory_limit\";\n    ErrorType[\"WRONG_ANSWER\"] = \"wrong_answer\";\n    ErrorType[\"COMPILATION\"] = \"compilation\";\n    ErrorType[\"UNKNOWN\"] = \"unknown\";\n})(ErrorType || (ErrorType = {}));\n// Error pattern categorization\nexport var ErrorPattern;\n(function (ErrorPattern) {\n    ErrorPattern[\"OFF_BY_ONE\"] = \"off_by_one\";\n    ErrorPattern[\"NULL_POINTER\"] = \"null_pointer\";\n    ErrorPattern[\"EDGE_CASE\"] = \"edge_case\";\n    ErrorPattern[\"BOUNDARY_CONDITION\"] = \"boundary_condition\";\n    ErrorPattern[\"INFINITE_LOOP\"] = \"infinite_loop\";\n    ErrorPattern[\"ARRAY_OUT_OF_BOUNDS\"] = \"array_out_of_bounds\";\n    ErrorPattern[\"STACK_OVERFLOW\"] = \"stack_overflow\";\n    ErrorPattern[\"INCORRECT_LOGIC\"] = \"incorrect_logic\";\n    ErrorPattern[\"TYPE_ERROR\"] = \"type_error\";\n    ErrorPattern[\"ASSIGNMENT_ERROR\"] = \"assignment_error\";\n    ErrorPattern[\"ALGORITHM_ERROR\"] = \"algorithm_error\";\n    ErrorPattern[\"DIVISION_BY_ZERO\"] = \"division_by_zero\";\n    ErrorPattern[\"UNCAUGHT_EXCEPTION\"] = \"uncaught_exception\";\n    ErrorPattern[\"UNDEFINED_VARIABLE\"] = \"undefined_variable\";\n    ErrorPattern[\"OTHER\"] = \"other\";\n})(ErrorPattern || (ErrorPattern = {}));\n// Categories of common programming concepts where errors occur\nexport var ErrorCategory;\n(function (ErrorCategory) {\n    ErrorCategory[\"LOOPS\"] = \"loops\";\n    ErrorCategory[\"CONDITIONALS\"] = \"conditionals\";\n    ErrorCategory[\"RECURSION\"] = \"recursion\";\n    ErrorCategory[\"DATA_STRUCTURES\"] = \"data_structures\";\n    ErrorCategory[\"ALGORITHMS\"] = \"algorithms\";\n    ErrorCategory[\"SYNTAX\"] = \"syntax\";\n    ErrorCategory[\"OPTIMIZATION\"] = \"optimization\";\n    ErrorCategory[\"VARIABLE_MANAGEMENT\"] = \"variable_management\";\n    ErrorCategory[\"TYPE_HANDLING\"] = \"type_handling\";\n    ErrorCategory[\"EDGE_CASES\"] = \"edge_cases\";\n    ErrorCategory[\"ERROR_HANDLING\"] = \"error_handling\";\n    ErrorCategory[\"OTHER\"] = \"other\";\n})(ErrorCategory || (ErrorCategory = {}));\n// Store of error patterns for frequency analysis\nconst errorPatterns = {};\n/**\n * Analyzes an error from a LeetCode submission or run\n */\nexport function analyzeError(statusMessage, errorMessage, code, language, failedTestCase, expectedOutput, actualOutput, problemId, problemTitle, problemDifficulty) {\n    // Initialize the error analysis object\n    const analysis = {\n        errorType: determineErrorType(statusMessage, errorMessage),\n        errorMessage: errorMessage || statusMessage || 'Unknown error',\n        problemContext: problemId ? {\n            problemId,\n            title: problemTitle || 'Unknown',\n            difficulty: problemDifficulty || 'Unknown'\n        } : undefined\n    };\n    // Extract line number from error message\n    const lineInfo = extractLineInfo(errorMessage || '', language);\n    if (lineInfo) {\n        analysis.lineNumber = lineInfo.lineNumber;\n        analysis.columnNumber = lineInfo.columnNumber;\n        // Extract code snippet around the error\n        if (analysis.lineNumber) {\n            analysis.codeSnippet = extractCodeSnippet(code, analysis.lineNumber);\n        }\n    }\n    // Add test case information if available\n    if (failedTestCase) {\n        analysis.failedTestCase = failedTestCase;\n    }\n    if (expectedOutput) {\n        analysis.expectedOutput = expectedOutput;\n    }\n    if (actualOutput) {\n        analysis.actualOutput = actualOutput;\n    }\n    // Determine error pattern\n    analysis.errorPattern = determineErrorPattern(analysis.errorType, errorMessage || '', code, expectedOutput, actualOutput);\n    // Categorize the error\n    analysis.errorCategory = categorizeError(analysis.errorType, analysis.errorPattern, code);\n    // Record this error pattern for frequency analysis\n    recordErrorPattern(analysis);\n    return analysis;\n}\n/**\n * Determines the type of error based on status message and error text\n */\nfunction determineErrorType(statusMessage, errorMessage) {\n    const status = statusMessage?.toLowerCase() || '';\n    const error = errorMessage?.toLowerCase() || '';\n    if (status.includes('time limit exceeded') || error.includes('time limit exceeded')) {\n        return ErrorType.TIME_LIMIT;\n    }\n    else if (status.includes('memory limit exceeded') || error.includes('memory limit exceeded')) {\n        return ErrorType.MEMORY_LIMIT;\n    }\n    else if (status.includes('wrong answer') || status.includes('output limit exceeded')) {\n        return ErrorType.WRONG_ANSWER;\n    }\n    else if (status.includes('compile error') || error.includes('syntax error') || error.includes('cannot compile')) {\n        return ErrorType.COMPILATION;\n    }\n    else if (status.includes('runtime error') ||\n        error.includes('null') ||\n        error.includes('undefined') ||\n        error.includes('cannot read property') ||\n        error.includes('index out of bounds') ||\n        error.includes('division by zero')) {\n        return ErrorType.RUNTIME;\n    }\n    else if (status.includes('accepted with warning') ||\n        status.includes('presentation error') ||\n        status.includes('partially correct')) {\n        return ErrorType.LOGICAL;\n    }\n    else if (status.includes('accepted')) {\n        // Even accepted solutions might have logical improvements\n        return ErrorType.LOGICAL;\n    }\n    return ErrorType.UNKNOWN;\n}\n/**\n * Extracts line and column information from error messages\n */\nfunction extractLineInfo(errorMessage, language) {\n    // Different languages have different error message formats\n    const lineMatches = {\n        // JavaScript/TypeScript line extraction patterns\n        javascript: [\n            /line\\s+(\\d+)[,\\s]+column\\s+(\\d+)/i, // line X, column Y\n            /at\\s+line\\s+(\\d+)/i, // at line X\n            /:(\\d+):(\\d+)/ // filename:X:Y\n        ],\n        typescript: [\n            /line\\s+(\\d+)[,\\s]+column\\s+(\\d+)/i,\n            /at\\s+line\\s+(\\d+)/i,\n            /:(\\d+):(\\d+)/\n        ],\n        python: [\n            /line\\s+(\\d+)/i, // line X\n            /File\\s+\".*\",\\s+line\\s+(\\d+)/i // File \"...\", line X\n        ],\n        java: [\n            /\\.java:(\\d+)/, // filename.java:X\n            /line\\s+(\\d+)/i // line X\n        ],\n        cpp: [\n            /\\.cpp:(\\d+):(\\d+)/, // filename.cpp:X:Y\n            /line\\s+(\\d+)/i // line X\n        ],\n        csharp: [\n            /\\.cs:(\\d+)/, // filename.cs:X\n            /line\\s+(\\d+)/i // line X\n        ],\n        go: [\n            /\\.go:(\\d+):(\\d+)/, // filename.go:X:Y\n            /line\\s+(\\d+)/i // line X\n        ]\n    };\n    // Default to javascript patterns if language not recognized\n    const patterns = lineMatches[language] || lineMatches.javascript;\n    // Try each pattern for the given language\n    for (const pattern of patterns) {\n        const match = errorMessage.match(pattern);\n        if (match) {\n            return {\n                lineNumber: parseInt(match[1], 10),\n                columnNumber: match[2] ? parseInt(match[2], 10) : undefined\n            };\n        }\n    }\n    // Try numeric extraction as a fallback\n    const numbersMatch = errorMessage.match(/(\\d+)/g);\n    if (numbersMatch && numbersMatch.length > 0) {\n        // Get the first number that could reasonably be a line number\n        const possibleLineNumber = parseInt(numbersMatch[0], 10);\n        if (possibleLineNumber > 0 && possibleLineNumber < 1000) {\n            return {\n                lineNumber: possibleLineNumber\n            };\n        }\n    }\n    return null;\n}\n/**\n * Extracts the code snippet around the error line\n */\nfunction extractCodeSnippet(code, lineNumber, contextLines = 2) {\n    const lines = code.split('\\n');\n    // Ensure line number is within range\n    if (lineNumber <= 0 || lineNumber > lines.length) {\n        return '';\n    }\n    // Get lines before and after the error line\n    const startLine = Math.max(0, lineNumber - contextLines - 1);\n    const endLine = Math.min(lines.length - 1, lineNumber + contextLines - 1);\n    // Extract the snippet with line numbers\n    let snippet = '';\n    for (let i = startLine; i <= endLine; i++) {\n        const isErrorLine = i === lineNumber - 1;\n        const lineNum = i + 1;\n        snippet += `${isErrorLine ? 'âž¤ ' : '  '}${lineNum}: ${lines[i]}\\n`;\n    }\n    return snippet.trim();\n}\n/**\n * Determines the error pattern based on the error type and message\n */\nfunction determineErrorPattern(errorType, errorMessage, code, expectedOutput, actualOutput) {\n    const message = errorMessage.toLowerCase();\n    // Check for specific runtime errors\n    if (errorType === ErrorType.RUNTIME) {\n        if (message.includes('null') ||\n            message.includes('undefined') ||\n            message.includes('nil') ||\n            message.includes('null pointer') ||\n            message.includes('nullpointer') ||\n            message.includes('cannot read property')) {\n            return ErrorPattern.NULL_POINTER;\n        }\n        if (message.includes('index out of') ||\n            message.includes('array index') ||\n            message.includes('out of bounds') ||\n            message.includes('range check')) {\n            return ErrorPattern.ARRAY_OUT_OF_BOUNDS;\n        }\n        if (message.includes('stack') &&\n            (message.includes('overflow') || message.includes('size'))) {\n            return ErrorPattern.STACK_OVERFLOW;\n        }\n        if (message.includes('divide by zero') ||\n            message.includes('division by zero') ||\n            message.includes('zerodivision')) {\n            return ErrorPattern.DIVISION_BY_ZERO;\n        }\n    }\n    // Check for wrong answer errors\n    if (errorType === ErrorType.WRONG_ANSWER) {\n        // If we have expected and actual output, try to analyze differences\n        if (expectedOutput && actualOutput) {\n            return analyzeOutputDifference(expectedOutput, actualOutput);\n        }\n        // Look for common logical error patterns in the code\n        if (/[<>]=?\\s*[+-]1/.test(code) || /[+-]1\\s*[<>]=?/.test(code)) {\n            return ErrorPattern.OFF_BY_ONE;\n        }\n        if (code.includes('while') && !code.includes('break')) {\n            return ErrorPattern.INFINITE_LOOP;\n        }\n    }\n    // Check for time limit issues\n    if (errorType === ErrorType.TIME_LIMIT) {\n        if (code.includes('for') && code.includes('for')) {\n            // Nested loops often cause time complexity issues\n            return ErrorPattern.ALGORITHM_ERROR;\n        }\n        return ErrorPattern.INFINITE_LOOP;\n    }\n    // Check for compilation/syntax errors\n    if (errorType === ErrorType.COMPILATION) {\n        if (message.includes('type') || message.includes('cannot convert')) {\n            return ErrorPattern.TYPE_ERROR;\n        }\n        if (message.includes('undeclared') ||\n            message.includes('undefined') ||\n            message.includes('not defined')) {\n            return ErrorPattern.UNDEFINED_VARIABLE;\n        }\n        if (message.includes('assignment') || message.includes('cannot assign')) {\n            return ErrorPattern.ASSIGNMENT_ERROR;\n        }\n    }\n    // Default patterns based on error type\n    switch (errorType) {\n        case ErrorType.SYNTAX:\n            return ErrorPattern.TYPE_ERROR;\n        case ErrorType.LOGICAL:\n            return ErrorPattern.INCORRECT_LOGIC;\n        case ErrorType.MEMORY_LIMIT:\n            return ErrorPattern.ALGORITHM_ERROR;\n        default:\n            return ErrorPattern.OTHER;\n    }\n}\n/**\n * Analyze the difference between expected and actual output\n */\nfunction analyzeOutputDifference(expected, actual) {\n    // Clean and parse outputs\n    const cleanExpected = expected.trim();\n    const cleanActual = actual.trim();\n    // Check for exact equality (should never happen for wrong answers)\n    if (cleanExpected === cleanActual) {\n        return ErrorPattern.OTHER;\n    }\n    // Check for off-by-one errors\n    const expectedNumbers = cleanExpected.match(/-?\\d+/g) || [];\n    const actualNumbers = cleanActual.match(/-?\\d+/g) || [];\n    if (expectedNumbers.length === actualNumbers.length) {\n        let offByOneCount = 0;\n        for (let i = 0; i < expectedNumbers.length; i++) {\n            const expNum = parseInt(expectedNumbers[i], 10);\n            const actNum = parseInt(actualNumbers[i], 10);\n            if (Math.abs(expNum - actNum) === 1) {\n                offByOneCount++;\n            }\n        }\n        // If a significant portion are off by one\n        if (offByOneCount > 0 && offByOneCount >= expectedNumbers.length * 0.3) {\n            return ErrorPattern.OFF_BY_ONE;\n        }\n    }\n    // Check for edge cases\n    if (cleanExpected === '0' || cleanExpected === '-1' || cleanExpected === '1') {\n        return ErrorPattern.EDGE_CASE;\n    }\n    // Check for boundary issues\n    if (expectedNumbers.length > 0 && actualNumbers.length > 0) {\n        const lastExpected = parseInt(expectedNumbers[expectedNumbers.length - 1], 10);\n        const lastActual = parseInt(actualNumbers[actualNumbers.length - 1], 10);\n        if (Math.abs(lastExpected - lastActual) === 1 ||\n            lastExpected === 0 && lastActual !== 0 ||\n            lastExpected !== 0 && lastActual === 0) {\n            return ErrorPattern.BOUNDARY_CONDITION;\n        }\n    }\n    return ErrorPattern.INCORRECT_LOGIC;\n}\n/**\n * Categorize the error into broader programming concepts\n */\nfunction categorizeError(errorType, errorPattern, code) {\n    // Map error patterns to categories\n    const patternToCategory = {\n        [ErrorPattern.OFF_BY_ONE]: ErrorCategory.LOOPS,\n        [ErrorPattern.NULL_POINTER]: ErrorCategory.VARIABLE_MANAGEMENT,\n        [ErrorPattern.EDGE_CASE]: ErrorCategory.EDGE_CASES,\n        [ErrorPattern.BOUNDARY_CONDITION]: ErrorCategory.EDGE_CASES,\n        [ErrorPattern.INFINITE_LOOP]: ErrorCategory.LOOPS,\n        [ErrorPattern.ARRAY_OUT_OF_BOUNDS]: ErrorCategory.DATA_STRUCTURES,\n        [ErrorPattern.STACK_OVERFLOW]: ErrorCategory.RECURSION,\n        [ErrorPattern.INCORRECT_LOGIC]: ErrorCategory.ALGORITHMS,\n        [ErrorPattern.TYPE_ERROR]: ErrorCategory.TYPE_HANDLING,\n        [ErrorPattern.ASSIGNMENT_ERROR]: ErrorCategory.VARIABLE_MANAGEMENT,\n        [ErrorPattern.ALGORITHM_ERROR]: ErrorCategory.ALGORITHMS,\n        [ErrorPattern.DIVISION_BY_ZERO]: ErrorCategory.EDGE_CASES,\n        [ErrorPattern.UNCAUGHT_EXCEPTION]: ErrorCategory.ERROR_HANDLING,\n        [ErrorPattern.UNDEFINED_VARIABLE]: ErrorCategory.VARIABLE_MANAGEMENT,\n        [ErrorPattern.OTHER]: ErrorCategory.OTHER\n    };\n    // If we have a pattern, use the mapping\n    if (errorPattern && patternToCategory[errorPattern]) {\n        return patternToCategory[errorPattern];\n    }\n    // Otherwise, determine category based on code content and error type\n    const lowerCode = code.toLowerCase();\n    if (errorType === ErrorType.TIME_LIMIT || errorType === ErrorType.MEMORY_LIMIT) {\n        return ErrorCategory.OPTIMIZATION;\n    }\n    if (errorType === ErrorType.COMPILATION || errorType === ErrorType.SYNTAX) {\n        return ErrorCategory.SYNTAX;\n    }\n    // Check for data structure issues\n    if (lowerCode.includes('array') ||\n        lowerCode.includes('list') ||\n        lowerCode.includes('map') ||\n        lowerCode.includes('set') ||\n        lowerCode.includes('queue') ||\n        lowerCode.includes('stack') ||\n        lowerCode.includes('heap')) {\n        return ErrorCategory.DATA_STRUCTURES;\n    }\n    // Check for loop issues\n    if (lowerCode.includes('for') ||\n        lowerCode.includes('while') ||\n        lowerCode.includes('iterator') ||\n        lowerCode.includes('index')) {\n        return ErrorCategory.LOOPS;\n    }\n    // Check for conditional logic\n    if (lowerCode.includes('if') ||\n        lowerCode.includes('else') ||\n        lowerCode.includes('switch') ||\n        lowerCode.includes('case') ||\n        lowerCode.includes('?') && lowerCode.includes(':')) {\n        return ErrorCategory.CONDITIONALS;\n    }\n    // Check for recursion\n    if ((code.match(/\\w+\\s*\\([^)]*\\)/g) || []).filter(call => {\n        const funcName = call.split('(')[0].trim();\n        return code.includes(`function ${funcName}`) || code.includes(`def ${funcName}`);\n    }).length > 0) {\n        return ErrorCategory.RECURSION;\n    }\n    return ErrorCategory.OTHER;\n}\n/**\n * Records error pattern for frequency analysis and sends to the backend\n */\nfunction recordErrorPattern(analysis) {\n    if (!analysis.errorPattern)\n        return;\n    const pattern = analysis.errorPattern.toString();\n    // Local tracking for immediate UI feedback\n    if (!errorPatterns[pattern]) {\n        errorPatterns[pattern] = {\n            count: 0,\n            lastSeen: Date.now(),\n            problems: new Set(),\n            examples: []\n        };\n    }\n    // Update pattern data\n    errorPatterns[pattern].count++;\n    errorPatterns[pattern].lastSeen = Date.now();\n    if (analysis.problemContext?.problemId) {\n        errorPatterns[pattern].problems.add(analysis.problemContext.problemId);\n    }\n    // Keep up to 3 examples of this error pattern\n    if (errorPatterns[pattern].examples.length < 3 && analysis.errorMessage) {\n        errorPatterns[pattern].examples.push(analysis.errorMessage);\n    }\n    // Send to backend API if problem context is available\n    if (analysis.problemContext?.problemId) {\n        sendErrorToBackend(analysis);\n    }\n}\n/**\n * Sends error data to the backend API for tracking and analysis\n */\nasync function sendErrorToBackend(analysis) {\n    try {\n        // Get API base URL from storage\n        // @ts-expect-error - process.env.API_BASE_URL is injected by webpack.DefinePlugin\n        const apiBaseUrl = localStorage.getItem('apiBaseUrl') || process.env.API_BASE_URL || 'http://localhost:3000';\n        // Prepare error data\n        const errorData = {\n            errorMessage: analysis.errorMessage,\n            errorType: analysis.errorType,\n            errorSubtype: analysis.errorPattern,\n            language: 'javascript', // Should be dynamic based on actual language\n            code: analysis.codeSnippet || '',\n            lineNumber: analysis.lineNumber,\n            columnNumber: analysis.columnNumber,\n            snippetContext: analysis.codeSnippet,\n            testCase: analysis.failedTestCase,\n            problemId: analysis.problemContext?.problemId,\n            patternName: analysis.errorPattern,\n            patternDescription: `${analysis.errorCategory || 'Unknown category'}: ${analysis.errorPattern}`\n        };\n        // Send to error tracking API\n        const response = await fetch(`${apiBaseUrl}/api/errors/track`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${localStorage.getItem('token') || ''}`\n            },\n            body: JSON.stringify(errorData)\n        });\n        if (!response.ok) {\n            console.error('Failed to send error to backend:', await response.text());\n        }\n    }\n    catch (error) {\n        console.error('Error sending error data to backend:', error);\n    }\n}\n/**\n * Get the most frequent error patterns for a user\n */\nexport function getFrequentErrorPatterns() {\n    return Object.entries(errorPatterns)\n        .map(([pattern, data]) => ({\n        pattern: pattern,\n        count: data.count,\n        problems: Array.from(data.problems),\n        examples: data.examples\n    }))\n        .sort((a, b) => b.count - a.count);\n}\n/**\n * Find similar errors to a given error\n */\nexport function findSimilarErrors(errorPattern, errorMessage) {\n    // First check for exact pattern match\n    if (errorPatterns[errorPattern]) {\n        return errorPatterns[errorPattern].examples.filter(e => e !== errorMessage);\n    }\n    // Otherwise find errors with same type\n    const similarErrors = [];\n    Object.entries(errorPatterns).forEach(([pattern, data]) => {\n        // Skip if pattern doesn't match our criteria\n        if (pattern !== errorPattern && pattern !== 'other') {\n            return;\n        }\n        // Add examples that are not the current error\n        data.examples.forEach(example => {\n            if (example !== errorMessage && !similarErrors.includes(example)) {\n                similarErrors.push(example);\n            }\n        });\n    });\n    return similarErrors.slice(0, 5); // Return at most 5 similar errors\n}\n/**\n * Calculate error similarity score between two errors\n */\nexport function calculateErrorSimilarity(error1, error2) {\n    let score = 0;\n    // Same error type is important\n    if (error1.errorType === error2.errorType) {\n        score += 0.3;\n    }\n    // Same error pattern is even more important\n    if (error1.errorPattern === error2.errorPattern) {\n        score += 0.4;\n    }\n    // Same category adds some similarity\n    if (error1.errorCategory === error2.errorCategory) {\n        score += 0.2;\n    }\n    // Text similarity in error messages\n    const message1 = error1.errorMessage.toLowerCase();\n    const message2 = error2.errorMessage.toLowerCase();\n    // Simple word overlap calculation\n    const words1 = message1.split(/\\s+/);\n    const words2 = message2.split(/\\s+/);\n    const uniqueWords = new Set([...words1, ...words2]);\n    let commonWords = 0;\n    uniqueWords.forEach(word => {\n        if (words1.includes(word) && words2.includes(word)) {\n            commonWords++;\n        }\n    });\n    const textSimilarity = uniqueWords.size > 0 ? commonWords / uniqueWords.size : 0;\n    score += textSimilarity * 0.1;\n    return Math.min(1, score);\n}\n/**\n * Clear error pattern history\n */\nexport function clearErrorPatterns() {\n    Object.keys(errorPatterns).forEach(key => {\n        delete errorPatterns[key];\n    });\n}\n","/**\n * LeetCode API service for accessing LeetCode's GraphQL API\n * This provides a more reliable way to get problem data than DOM scraping\n */\n/**\n * Service for interacting with LeetCode's GraphQL API\n */\nexport class LeetCodeAPI {\n    constructor() {\n        this.endpoint = 'https://leetcode.com/graphql';\n    }\n    /**\n     * Fetch problem data by title slug (URL slug)\n     */\n    async getProblemData(titleSlug) {\n        const query = `\n      query questionData($titleSlug: String!) {\n        question(titleSlug: $titleSlug) {\n          questionId\n          questionFrontendId\n          title\n          titleSlug\n          content\n          difficulty\n          topicTags {\n            name\n            slug\n          }\n          exampleTestcases\n          codeSnippets {\n            lang\n            langSlug\n            code\n          }\n        }\n      }\n    `;\n        try {\n            const response = await fetch(this.endpoint, {\n                method: 'POST',\n                credentials: 'include', // Important: includes cookies for authentication\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: { titleSlug }\n                })\n            });\n            const data = await response.json();\n            if (data.errors) {\n                console.error('GraphQL API error:', data.errors);\n                return null;\n            }\n            return data.data.question;\n        }\n        catch (error) {\n            console.error('Error fetching problem data:', error);\n            return null;\n        }\n    }\n    /**\n     * Fetch user's submissions for a problem\n     */\n    async getSubmissions(titleSlug, limit = 20) {\n        const query = `\n      query submissionList($questionSlug: String!, $limit: Int!) {\n        submissionList(questionSlug: $questionSlug, limit: $limit) {\n          submissions {\n            id\n            statusDisplay\n            lang\n            runtime\n            timestamp\n            url\n            memory\n            code\n          }\n        }\n      }\n    `;\n        try {\n            const response = await fetch(this.endpoint, {\n                method: 'POST',\n                credentials: 'include', // Important: includes cookies for authentication\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: {\n                        questionSlug: titleSlug,\n                        limit\n                    }\n                })\n            });\n            const data = await response.json();\n            if (data.errors) {\n                console.error('GraphQL API error:', data.errors);\n                return [];\n            }\n            return data.data.submissionList.submissions;\n        }\n        catch (error) {\n            console.error('Error fetching submissions:', error);\n            return [];\n        }\n    }\n    /**\n     * Fetch details for a specific submission by ID\n     */\n    async getSubmissionDetail(submissionId) {\n        const query = `\n      query submissionDetails($submissionId: ID!) {\n        submissionDetails(submissionId: $submissionId) {\n          code\n          runtime\n          memory\n          statusDisplay\n          timestamp\n          lang\n          passedTestCaseCnt\n          totalTestCaseCnt\n          statusRuntime\n          runtimeError\n          compileError\n        }\n      }\n    `;\n        try {\n            const response = await fetch(this.endpoint, {\n                method: 'POST',\n                credentials: 'include',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: { submissionId }\n                })\n            });\n            const data = await response.json();\n            if (data.errors) {\n                console.error('GraphQL API error:', data.errors);\n                return null;\n            }\n            return data.data.submissionDetails;\n        }\n        catch (error) {\n            console.error('Error fetching submission details:', error);\n            return null;\n        }\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { LeetCodeAPI } from '../lib/leetcode-api';\nimport { analyzeError } from '../lib/error-analyzer';\n// Initialize the LeetCode API\nconst leetcodeApi = new LeetCodeAPI();\n// Track solution versions for the current problem\nconst solutionVersionsMap = {};\nlet currentLanguage = 'unknown';\n// Global variables for problem identification\nlet problemId = '';\nlet problemTitle = '';\n// Add this at the top level, before other functions\n// Global flag to track if Monaco is ready\nlet isMonacoReady = false;\n// Global helper to get Monaco editors with safety checks\nfunction getMonacoEditors() {\n    try {\n        // Try the standard approach first\n        if (window.monaco && window.monaco.editor && typeof window.monaco.editor.getEditors === 'function') {\n            const editors = window.monaco.editor.getEditors();\n            if (editors && Array.isArray(editors) && editors.length > 0) {\n                return editors;\n            }\n        }\n        // If standard approach fails, try alternative methods\n        // Method 1: Look for monaco through _monaco property that some implementations use\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const windowAny = window;\n        if (windowAny._monaco && windowAny._monaco.editor && typeof windowAny._monaco.editor.getEditors === 'function') {\n            const editors = windowAny._monaco.editor.getEditors();\n            if (editors && Array.isArray(editors) && editors.length > 0) {\n                console.log(\"DSA Tracker: Found Monaco editors via _monaco property\");\n                return editors;\n            }\n        }\n        // Method 2: Try to find monaco in window properties\n        for (const key in window) {\n            try {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const prop = window[key];\n                if (prop && typeof prop === 'object' && prop.editor && typeof prop.editor.getEditors === 'function') {\n                    const editors = prop.editor.getEditors();\n                    if (editors && Array.isArray(editors) && editors.length > 0) {\n                        console.log(`DSA Tracker: Found Monaco editors via window.${key}`);\n                        return editors;\n                    }\n                }\n            }\n            catch (err) {\n                void err; // Acknowledge unused variable\n                // Ignore property access errors\n            }\n        }\n        // Method 3: Try to find the editor instance directly in the DOM\n        const monacoElements = document.querySelectorAll('.monaco-editor');\n        if (monacoElements.length > 0) {\n            // Some Monaco implementations store editor instances in DOM data\n            for (let i = 0; i < monacoElements.length; i++) {\n                try {\n                    const editorElement = monacoElements[i];\n                    // Try to get editor instance from DOM element\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const editorInstance = editorElement._tokenization?.editor ||\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        editorElement.editor ||\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        editorElement.__editor;\n                    if (editorInstance && typeof editorInstance.getValue === 'function') {\n                        console.log(\"DSA Tracker: Found Monaco editor instance in DOM element\");\n                        return [editorInstance];\n                    }\n                }\n                catch (err) {\n                    void err; // Acknowledge unused variable\n                    // Ignore property access errors\n                }\n            }\n        }\n    }\n    catch (e) {\n        void e; // Acknowledge unused variable\n        console.error(\"DSA Tracker: Error accessing Monaco editors\", e);\n    }\n    return null;\n}\n// For debugging\nconsole.log(\"DSA Tracker: Content script loaded on \" + window.location.href);\n// Initialize tracking when the page loads\ninitializeTracking();\n// Listen for messages from the popup or background script\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n    console.log(\"DSA Tracker: Received message\", message);\n    if (message.action === 'getProblemInfo') {\n        getProblemInfo().then(sendResponse);\n        return true; // Required to use sendResponse asynchronously\n    }\n    else if (message.action === 'captureError') {\n        captureError().then(sendResponse);\n        return true; // Required to use sendResponse asynchronously\n    }\n    else if (message.action === 'extractTestCases') {\n        extractTestCases().then(sendResponse);\n        return true; // Required to use sendResponse asynchronously\n    }\n    else if (message.action === 'initializeTracking') {\n        initializeTracking();\n        sendResponse({ success: true });\n        return true;\n    }\n    else if (message.action === 'getSolutionVersions') {\n        const titleSlug = getUrlSlug();\n        const versions = titleSlug ? solutionVersionsMap[titleSlug] || [] : [];\n        sendResponse({ versions });\n        return true;\n    }\n    return false; // Default case\n});\n// Initialize tracking by setting up network interceptors\nasync function initializeTracking() {\n    // Detect current programming language\n    detectLanguage();\n    // Set up network interception - this is where we'll capture Run and Submit actions\n    setupNetworkInterception();\n    // Set up language change detection\n    setupLanguageChangeDetection();\n    // Get the URL slug, but don't create a problem yet - only load existing solutions\n    const titleSlug = getUrlSlug();\n    if (titleSlug) {\n        const versions = await loadSolutionVersions(titleSlug);\n        solutionVersionsMap[titleSlug] = versions;\n        console.log(`DSA Tracker: Loaded ${versions.length} saved solution versions for ${titleSlug}`);\n    }\n    console.log(\"DSA Tracker: Tracking initialized for\", window.location.href);\n}\n// Get the current URL slug from the window location\nfunction getUrlSlug() {\n    const path = window.location.pathname;\n    const match = path.match(/\\/problems\\/([^/]+)/);\n    return match ? match[1] : null;\n}\n// Detect the programming language currently being used\nfunction detectLanguage() {\n    // Look for language selector in the UI with updated selectors\n    const languageSelector = document.querySelector('.ant-select-selection-item') ||\n        document.querySelector('[data-cy=\"lang-select\"]') ||\n        document.querySelector('.select-lang') ||\n        document.querySelector('.relative.text-label-1') || // New selector\n        document.querySelector('[data-mode]') || // Code editor might have data-mode attribute\n        document.querySelector('[data-track-load=\"code_editor\"]'); // Another possible selector\n    if (languageSelector && languageSelector.textContent) {\n        const text = languageSelector.textContent.toLowerCase();\n        if (text.includes('javascript'))\n            currentLanguage = 'javascript';\n        else if (text.includes('typescript'))\n            currentLanguage = 'typescript';\n        else if (text.includes('python'))\n            currentLanguage = 'python';\n        else if (text.includes('java'))\n            currentLanguage = 'java';\n        else if (text.includes('c++'))\n            currentLanguage = 'cpp';\n        else if (text.includes('c#'))\n            currentLanguage = 'csharp';\n        else if (text.includes('go'))\n            currentLanguage = 'go';\n        else if (text.includes('case 1'))\n            currentLanguage = 'java'; // LeetCode shows \"case 1\" for Java sometimes\n        else if (text.includes('case 2'))\n            currentLanguage = 'python'; // LeetCode shows \"case 2\" for Python sometimes\n        else\n            currentLanguage = text.trim();\n        console.log(\"DSA Tracker: Detected language:\", currentLanguage);\n    }\n    else {\n        // Try alternative approach - check code editor attributes\n        const editorElement = document.querySelector('.monaco-editor');\n        if (editorElement) {\n            const editorLanguage = editorElement.getAttribute('data-language') ||\n                editorElement.getAttribute('data-mode');\n            if (editorLanguage) {\n                currentLanguage = editorLanguage.toLowerCase();\n                console.log(\"DSA Tracker: Detected language from editor:\", currentLanguage);\n                return;\n            }\n        }\n        // Try to infer from code content\n        const tryDetectFromCode = () => {\n            // Get code from editor or textarea\n            let code = '';\n            if (window.monaco?.editor) {\n                try {\n                    const editors = window.monaco.editor.getEditors();\n                    if (editors?.length > 0) {\n                        code = editors[0].getValue() || '';\n                    }\n                }\n                catch (err) {\n                    void err; // Acknowledge unused variable\n                    // Ignore errors\n                }\n            }\n            if (!code) {\n                // Try textareas\n                const textareas = document.querySelectorAll('textarea');\n                for (const textarea of textareas) {\n                    if (textarea.value?.length > 20) {\n                        code = textarea.value;\n                        break;\n                    }\n                }\n            }\n            // Analyze code to guess the language\n            if (code) {\n                if (code.includes('public class') || code.includes('import java.')) {\n                    return 'java';\n                }\n                else if (code.includes('func ') && code.includes('package ')) {\n                    return 'go';\n                }\n                else if (code.includes('def ') && code.includes(':')) {\n                    return 'python';\n                }\n                else if (code.includes('function') || code.includes('const ') || code.includes('let ')) {\n                    return 'javascript';\n                }\n                else if (code.includes('#include') || code.includes('vector<')) {\n                    return 'cpp';\n                }\n            }\n            return null;\n        };\n        // Try to detect from code\n        const detectedLang = tryDetectFromCode();\n        if (detectedLang) {\n            currentLanguage = detectedLang;\n            console.log(\"DSA Tracker: Detected language from code:\", currentLanguage);\n            return;\n        }\n        // Try to infer from URL or problem metadata\n        if (window.location.pathname.includes('/java/') || document.querySelector('.java-code')) {\n            currentLanguage = 'java';\n        }\n        else if (window.location.pathname.includes('/python/') || document.querySelector('.python-code')) {\n            currentLanguage = 'python';\n        }\n        else if (window.location.pathname.includes('/javascript/') || document.querySelector('.js-code')) {\n            currentLanguage = 'javascript';\n        }\n        else {\n            // Default to JavaScript if we can't detect\n            currentLanguage = 'javascript';\n            console.log(\"DSA Tracker: Could not detect language, defaulting to JavaScript\");\n        }\n    }\n}\n// Setup detection for language changes\nfunction setupLanguageChangeDetection() {\n    // Watch for changes to the language selector with updated selectors\n    const observer = new MutationObserver(() => {\n        detectLanguage();\n    });\n    const languageSelector = document.querySelector('.ant-select-selection-item') ||\n        document.querySelector('[data-cy=\"lang-select\"]') ||\n        document.querySelector('.select-lang') ||\n        document.querySelector('.relative.text-label-1') || // New selector\n        document.querySelector('[data-track-load=\"code_editor\"]'); // Another selector\n    if (languageSelector) {\n        observer.observe(languageSelector, {\n            childList: true,\n            subtree: true,\n            characterData: true\n        });\n    }\n    // Also observe the monaco editor for language changes\n    const editorElement = document.querySelector('.monaco-editor');\n    if (editorElement) {\n        observer.observe(editorElement, {\n            attributes: true,\n            attributeFilter: ['data-language', 'data-mode'],\n            subtree: true\n        });\n    }\n}\n// Set up interception of network requests\nfunction setupNetworkInterception() {\n    // Prevent double-patching fetch\n    if (window.fetch.isPatchedByDSATracker) {\n        console.log(\"DSA Tracker: Fetch is already patched.\");\n        return;\n    }\n    console.log(\"DSA Tracker: Setting up network interception\");\n    // Store the original fetch function\n    const originalFetch = window.fetch;\n    // Monkey patch fetch to intercept network requests\n    window.fetch = async function (input, init) {\n        const url = typeof input === 'string'\n            ? input\n            : input instanceof Request ? input.url : input.toString();\n        // Only debug important requests to reduce console noise\n        const isCodeRun = (url.includes('/interpret_solution/') ||\n            url.includes('/problems/') && url.includes('/interpret_solution'));\n        const isSubmission = (url.includes('/submit/') ||\n            url.includes('/problems/') && url.includes('/submit'));\n        // For debugging important requests\n        if (isCodeRun || isSubmission) {\n            console.log(\"DSA Tracker: IMPORTANT REQUEST DETECTED:\", {\n                url,\n                isCodeRun,\n                isSubmission,\n                method: init?.method || 'GET',\n                hasBody: !!init?.body\n            });\n            // Fix the issue with possibly undefined 'init' parameter\n            // Log the body for debugging if present\n            if (init?.body) {\n                try {\n                    const bodyContent = typeof init.body === 'string'\n                        ? init.body\n                        : init.body instanceof FormData\n                            ? 'FormData object (cannot stringify)'\n                            : JSON.stringify(init.body);\n                    console.log(\"DSA Tracker: Request body:\", bodyContent);\n                }\n                catch (e) {\n                    void e; // Acknowledge unused variable\n                    console.log(\"DSA Tracker: Could not log body\");\n                }\n            }\n        }\n        // Continue with the original fetch to get the response\n        const response = await originalFetch.apply(this, [input, init]);\n        try {\n            // Only process important requests - Run and Submit actions\n            if (isCodeRun || isSubmission) {\n                // Clone the response so we can read it multiple times\n                const responseClone = response.clone();\n                // Get problem metadata\n                const problemId = getProblemIdFromUrl(window.location.href);\n                if (!problemId) {\n                    console.warn(\"DSA Tracker: Not on a problem page, skipping interception logic.\");\n                    return response; // Not on a problem page\n                }\n                const problemTitle = document.querySelector('div[data-cy=\"question-title\"]')?.textContent?.trim() || '';\n                // For code runs (checking solution)\n                if (isCodeRun) {\n                    console.log(\"DSA Tracker: Detected code run request\");\n                    // Extract the code from the request body\n                    let code = '';\n                    let language = '';\n                    let inputData = '';\n                    if (init && init.body) {\n                        try {\n                            // If it's a string, parse it as JSON\n                            const body = typeof init.body === 'string'\n                                ? JSON.parse(init.body)\n                                : init.body;\n                            console.log(\"DSA Tracker: Request body keys:\", Object.keys(body));\n                            // Extract code and language\n                            if (body.typed_code) {\n                                code = body.typed_code;\n                                console.log(\"DSA Tracker: Extracted code (length):\", code.length);\n                            }\n                            else if (body.question && body.question.code) {\n                                // Alternative location in newer LeetCode versions\n                                code = body.question.code;\n                                console.log(\"DSA Tracker: Extracted code from alternative location (length):\", code.length);\n                            }\n                            if (body.lang) {\n                                language = body.lang;\n                                console.log(\"DSA Tracker: Extracted language:\", language);\n                            }\n                            else if (body.lang_slug) {\n                                language = body.lang_slug;\n                                console.log(\"DSA Tracker: Extracted language from lang_slug:\", language);\n                            }\n                            else if (body.question && body.question.lang) {\n                                language = body.question.lang;\n                                console.log(\"DSA Tracker: Extracted language from question.lang:\", language);\n                            }\n                            if (body.data_input) {\n                                inputData = body.data_input;\n                                console.log(\"DSA Tracker: Extracted input data (length):\", inputData.length);\n                            }\n                            else if (body.params) {\n                                inputData = body.params;\n                                console.log(\"DSA Tracker: Extracted input data from params (length):\", inputData.length);\n                            }\n                        }\n                        catch (e) {\n                            void e; // Acknowledge unused variable\n                            console.error(\"DSA Tracker: Error parsing request body\", e);\n                        }\n                    }\n                    if (code && language) {\n                        // Generate a unique ID for this run\n                        const runId = `run_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n                        // Create a new solution version for this run\n                        const version = {\n                            id: runId,\n                            problemId,\n                            code,\n                            language,\n                            status: 'running',\n                            timestamp: Date.now(),\n                            isSubmission: false,\n                            runId,\n                            input: inputData,\n                            expectedOutput: '', // Will be filled from the response\n                        };\n                        // Get previous versions to compare changes\n                        const previousVersions = await getVersionsFromStorage(problemId);\n                        if (previousVersions.length > 0) {\n                            // Calculate changes compared to the latest version\n                            const latestVersion = previousVersions[0];\n                            version.changes = calculateCodeChanges(latestVersion.code, code);\n                        }\n                        // Store the new version temporarily\n                        await storeVersionInStorage(version);\n                        // Process the response to update status and results\n                        responseClone.json().then(async (data) => {\n                            try {\n                                console.log(\"DSA Tracker: Run response keys:\", Object.keys(data));\n                                // Handle different response formats\n                                const isSuccess = data.run_success !== undefined\n                                    ? data.run_success\n                                    : data.state === 'SUCCESS';\n                                // Update the version with results\n                                version.status = isSuccess ? 'passed' : 'failed';\n                                // Extract output based on different response formats\n                                if (data.code_answer) {\n                                    version.output = Array.isArray(data.code_answer)\n                                        ? data.code_answer.join('\\n')\n                                        : String(data.code_answer);\n                                }\n                                else if (data.code_output) {\n                                    version.output = Array.isArray(data.code_output)\n                                        ? data.code_output.join('\\n')\n                                        : String(data.code_output);\n                                }\n                                else if (data.stdout) {\n                                    version.output = data.stdout;\n                                }\n                                // Extract expected output\n                                if (data.expected_code_answer) {\n                                    version.expectedOutput = Array.isArray(data.expected_code_answer)\n                                        ? data.expected_code_answer.join('\\n')\n                                        : String(data.expected_code_answer);\n                                }\n                                else if (data.expected_output) {\n                                    version.expectedOutput = data.expected_output;\n                                }\n                                // Extract runtime metrics\n                                version.executionTime = data.status_runtime || data.runtime || '';\n                                version.memoryUsed = data.status_memory || data.memory || '';\n                                // If there's an error, analyze it\n                                if (!isSuccess) {\n                                    const errorMessage = data.status_msg || data.error_msg || data.message || 'Unknown error';\n                                    version.errorMessage = errorMessage;\n                                    // Analyze the error\n                                    const analyzer = new ErrorAnalyzer();\n                                    version.errorAnalysis = analyzer.analyzeError({\n                                        errorMessage: errorMessage,\n                                        language: language,\n                                        code: code,\n                                        problemId: problemId,\n                                        problemTitle: problemTitle,\n                                        failedTestCase: inputData\n                                    });\n                                }\n                                console.log(\"DSA Tracker: Processed run response:\", {\n                                    status: version.status,\n                                    hasOutput: !!version.output,\n                                    hasError: !!version.errorMessage\n                                });\n                                // Update the stored version\n                                await storeVersionInStorage(version);\n                                // Send the code run to the backend\n                                await sendCodeRunToBackend(version);\n                            }\n                            catch (err) {\n                                void err; // Acknowledge unused variable\n                                console.error(\"DSA Tracker: Error processing code run response\", err);\n                            }\n                        }).catch(e => {\n                            void e; // Acknowledge unused variable\n                            console.error(\"DSA Tracker: Error processing code run response JSON\", e);\n                        });\n                    }\n                    // For submissions\n                    if (isSubmission) {\n                        console.log(\"DSA Tracker: Detected submission request\");\n                        // Extract the code from the request body\n                        let code = '';\n                        let language = '';\n                        if (init && init.body) {\n                            try {\n                                // If it's a string, parse it as JSON\n                                const body = typeof init.body === 'string'\n                                    ? JSON.parse(init.body)\n                                    : init.body;\n                                console.log(\"DSA Tracker: Submission request body keys:\", Object.keys(body));\n                                // Extract code and language\n                                if (body.typed_code) {\n                                    code = body.typed_code;\n                                    console.log(\"DSA Tracker: Extracted submission code (length):\", code.length);\n                                }\n                                else if (body.question && body.question.code) {\n                                    // Alternative location in newer LeetCode versions\n                                    code = body.question.code;\n                                    console.log(\"DSA Tracker: Extracted submission code from alternative location (length):\", code.length);\n                                }\n                                else if (body.submission_code) {\n                                    code = body.submission_code;\n                                    console.log(\"DSA Tracker: Extracted submission code from submission_code (length):\", code.length);\n                                }\n                                if (body.lang) {\n                                    language = body.lang;\n                                    console.log(\"DSA Tracker: Extracted submission language:\", language);\n                                }\n                                else if (body.lang_slug) {\n                                    language = body.lang_slug;\n                                    console.log(\"DSA Tracker: Extracted submission language from lang_slug:\", language);\n                                }\n                                else if (body.question && body.question.lang) {\n                                    language = body.question.lang;\n                                    console.log(\"DSA Tracker: Extracted submission language from question.lang:\", language);\n                                }\n                            }\n                            catch (e) {\n                                void e; // Acknowledge unused variable\n                                console.error(\"DSA Tracker: Error parsing submission request body\", e);\n                            }\n                        }\n                        if (code && language) {\n                            // Generate a unique ID for this submission\n                            const submissionId = `sub_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n                            // Create a new solution version for this submission\n                            const version = {\n                                id: submissionId,\n                                problemId,\n                                code,\n                                language,\n                                status: 'submitted',\n                                timestamp: Date.now(),\n                                isSubmission: true,\n                                submissionId,\n                            };\n                            // Get previous versions to compare changes\n                            const previousVersions = await getVersionsFromStorage(problemId);\n                            if (previousVersions.length > 0) {\n                                // Calculate changes compared to the latest version\n                                const latestVersion = previousVersions[0];\n                                version.changes = calculateCodeChanges(latestVersion.code, code);\n                            }\n                            // Store the new version temporarily\n                            await storeVersionInStorage(version);\n                            // Process the response to update status and results\n                            responseClone.json().then(async (data) => {\n                                try {\n                                    console.log(\"DSA Tracker: Submission response keys:\", Object.keys(data));\n                                    // Extract submission ID from response\n                                    if (data.submission_id) {\n                                        version.submissionId = data.submission_id;\n                                    }\n                                    else if (data.id) {\n                                        version.submissionId = data.id;\n                                    }\n                                    // Update the version with results\n                                    // 10 is the code for \"Accepted\" in most LeetCode responses\n                                    const isAccepted = data.status_code === 10 || data.status === 'Accepted' || data.state === 'SUCCESS';\n                                    version.status = isAccepted ? 'accepted' : 'failed';\n                                    // Extract runtime metrics\n                                    version.executionTime = data.status_runtime || data.runtime || '';\n                                    version.memoryUsed = data.status_memory || data.memory || '';\n                                    // If there's an error, analyze it\n                                    if (!isAccepted) {\n                                        const errorMessage = data.status_msg || data.error_msg || data.message || 'Unknown error';\n                                        version.errorMessage = errorMessage;\n                                        // Determine test case input if available\n                                        const failedTestCase = data.input || data.last_testcase || '';\n                                        // Analyze the error\n                                        const analyzer = new ErrorAnalyzer();\n                                        version.errorAnalysis = analyzer.analyzeError({\n                                            errorMessage: errorMessage,\n                                            language: language,\n                                            code: code,\n                                            problemId: problemId,\n                                            problemTitle: problemTitle,\n                                            failedTestCase: failedTestCase\n                                        });\n                                    }\n                                    console.log(\"DSA Tracker: Processed submission response:\", {\n                                        status: version.status,\n                                        isAccepted: isAccepted,\n                                        hasError: !!version.errorMessage\n                                    });\n                                    // Update the stored version\n                                    await storeVersionInStorage(version);\n                                    // Send the submission to the backend\n                                    await sendSubmissionToBackend(version);\n                                }\n                                catch (err) {\n                                    void err; // Acknowledge unused variable\n                                    console.error(\"DSA Tracker: Error processing submission response\", err);\n                                }\n                            }).catch(e => {\n                                void e; // Acknowledge unused variable\n                                console.error(\"DSA Tracker: Error processing submission response JSON\", e);\n                            });\n                        }\n                        else {\n                            console.log(\"DSA Tracker: Failed to extract code or language from submission request body\");\n                        }\n                    }\n                }\n            }\n        }\n        catch (error) {\n            void error; // Acknowledge unused variable\n            console.error(\"DSA Tracker: Error in fetch interception\", error);\n        }\n        // Always return the original response\n        return response;\n    };\n    // Mark fetch as patched\n    window.fetch.isPatchedByDSATracker = true;\n    console.log(\"DSA Tracker: Network interception setup complete\");\n}\n// Calculate code changes function\nfunction calculateCodeChanges(oldCode, newCode) {\n    if (!oldCode || !newCode) {\n        return { addedLines: 0, removedLines: 0, modifiedLines: 0 };\n    }\n    const oldLines = oldCode.split('\\n');\n    const newLines = newCode.split('\\n');\n    const addedLines = Math.max(0, newLines.length - oldLines.length);\n    const removedLines = Math.max(0, oldLines.length - newLines.length);\n    // Simple diff - count lines that are different\n    let modifiedLines = 0;\n    const minLength = Math.min(oldLines.length, newLines.length);\n    for (let i = 0; i < minLength; i++) {\n        if (oldLines[i] !== newLines[i]) {\n            modifiedLines++;\n        }\n    }\n    return { addedLines, removedLines, modifiedLines };\n}\n// Store a solution version to local storage and send to backend\nfunction storeSolutionVersion(titleSlug, version) {\n    try {\n        // Store locally first\n        chrome.storage.local.get(['solutionVersions'], (result) => {\n            const allVersions = result.solutionVersions || {};\n            allVersions[titleSlug] = allVersions[titleSlug] || [];\n            // Find if we already have this version\n            const existingIndex = allVersions[titleSlug].findIndex((v) => v.id === version.id);\n            if (existingIndex >= 0) {\n                // Update existing version\n                allVersions[titleSlug][existingIndex] = version;\n            }\n            else {\n                // Add new version\n                allVersions[titleSlug].push(version);\n            }\n            // Limit to 50 versions per problem to prevent storage issues\n            if (allVersions[titleSlug].length > 50) {\n                allVersions[titleSlug] = allVersions[titleSlug].slice(-50);\n            }\n            // Save back to local storage\n            chrome.storage.local.set({ solutionVersions: allVersions }, () => {\n                console.log(\"DSA Tracker: Saved solution version to local storage\");\n            });\n        });\n        // If this is a submission with a submissionId, send to backend\n        if (version.isSubmission && version.submissionId) {\n            sendVersionToBackend(version);\n        }\n    }\n    catch (error) {\n        void error; // Acknowledge unused variable\n        console.error(\"DSA Tracker: Error storing solution version:\", error);\n    }\n}\n// Send solution version to backend\nasync function sendVersionToBackend(version) {\n    try {\n        // Get API base URL and auth token\n        // @ts-expect-error - process.env.API_BASE_URL is injected by webpack.DefinePlugin\n        const apiBaseUrl = localStorage.getItem('apiBaseUrl') || process.env.API_BASE_URL || 'http://localhost:3000';\n        const token = localStorage.getItem('token');\n        // Only proceed if we have a token\n        if (!token) {\n            console.log(\"DSA Tracker: Not sending solution version to backend - no authentication token\");\n            return;\n        }\n        // Extract or create a submission ID\n        const submissionId = version.submissionId;\n        // If there's no submissionId but we have a problem tracked in our system,\n        // we'll need to first create a submission record\n        if (!submissionId) {\n            // We could make an API call to create a submission first\n            // For now, we'll skip versions without a submissionId\n            return;\n        }\n        // Include code changes data for AI analysis if available\n        const codeChanges = version.changes ? {\n            addedLines: version.changes.addedLines,\n            removedLines: version.changes.removedLines,\n            modifiedLines: version.changes.modifiedLines\n        } : undefined;\n        // Prepare version data\n        const versionData = {\n            submissionId: submissionId,\n            code: version.code,\n            language: version.language,\n            versionNumber: undefined, // Let the backend assign a number\n            changelog: `${version.isSubmission ? 'Submission' : 'Run'} - ${version.status}`,\n            codeChanges: codeChanges // Include code changes for AI analysis\n        };\n        // Send to solution versions API\n        const response = await fetch(`${apiBaseUrl}/api/solutions/versions`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${token}`\n            },\n            body: JSON.stringify(versionData)\n        });\n        if (!response.ok) {\n            void response.text().then(text => console.error('Failed to send solution version to backend:', text));\n        }\n        else {\n            console.log(\"DSA Tracker: Saved solution version to backend\");\n        }\n    }\n    catch (error) {\n        void error; // Acknowledge unused variable\n        console.error(\"DSA Tracker: Error sending solution version to backend:\", error);\n    }\n}\n// Load solution versions from local storage\nfunction loadSolutionVersions(titleSlug) {\n    return new Promise((resolve) => {\n        chrome.storage.local.get(['solutionVersions'], (result) => {\n            const allVersions = result.solutionVersions || {};\n            const versions = allVersions[titleSlug] || [];\n            resolve(versions);\n        });\n    });\n}\n// Extract problem information using the GraphQL API\nasync function getProblemInfo() {\n    try {\n        const titleSlug = getUrlSlug();\n        if (!titleSlug) {\n            return { success: false, message: 'Not a LeetCode problem page' };\n        }\n        // Use the GraphQL API to get problem data\n        const problemData = await leetcodeApi.getProblemData(titleSlug);\n        if (!problemData) {\n            return { success: false, message: 'Failed to fetch problem data' };\n        }\n        // Transform the problem data to the expected format\n        const problem = {\n            title: problemData.title,\n            leetcodeId: problemData.titleSlug,\n            difficulty: problemData.difficulty,\n            url: window.location.href,\n            timestamp: Date.now(),\n            description: problemData.content,\n            examples: problemData.exampleTestcases,\n            tags: problemData.topicTags.map(tag => tag.name)\n        };\n        return { success: true, problem };\n    }\n    catch (error) {\n        void error; // Acknowledge unused variable\n        console.error('Error extracting problem info:', error);\n        return { success: false, message: 'Error extracting problem info', error: String(error) };\n    }\n}\n// Extract error information from the page\nasync function captureError() {\n    try {\n        const titleSlug = getUrlSlug();\n        if (!titleSlug) {\n            return { success: false, message: 'Not a LeetCode problem page' };\n        }\n        // Get problem data from the API\n        const problemData = await leetcodeApi.getProblemData(titleSlug);\n        if (!problemData) {\n            return { success: false, message: 'Failed to fetch problem data' };\n        }\n        // Get the latest submission (if any)\n        const submissions = await leetcodeApi.getSubmissions(titleSlug, 1);\n        if (!submissions || submissions.length === 0) {\n            return { success: false, message: 'No submissions found' };\n        }\n        const latestSubmission = submissions[0];\n        // Create error data object\n        const errorData = {\n            problemId: problemData.questionFrontendId,\n            problemTitle: problemData.title,\n            language: latestSubmission.lang,\n            code: latestSubmission.code,\n            error: latestSubmission.statusDisplay !== 'Accepted' ? latestSubmission.statusDisplay : 'No error',\n            timestamp: new Date().toISOString(),\n            url: window.location.href,\n        };\n        return { success: true, error: errorData };\n    }\n    catch (error) {\n        void error; // Acknowledge unused variable\n        console.error('Error capturing error:', error);\n        return { success: false, message: 'Error capturing error data', error: String(error) };\n    }\n}\n// Extract test cases from the problem\nasync function extractTestCases() {\n    try {\n        const titleSlug = getUrlSlug();\n        if (!titleSlug) {\n            return { success: false, message: 'Not a LeetCode problem page' };\n        }\n        // Get problem data from the API\n        const problemData = await leetcodeApi.getProblemData(titleSlug);\n        if (!problemData) {\n            return { success: false, message: 'Failed to fetch problem data' };\n        }\n        // Parse example test cases\n        const testCases = problemData.exampleTestcases.split('\\n');\n        // Get the latest submission (if any)\n        const submissions = await leetcodeApi.getSubmissions(titleSlug, 1);\n        // Create test case data object\n        const testCaseData = {\n            problemId: problemData.questionFrontendId,\n            problemTitle: problemData.title,\n            language: submissions.length > 0 ? submissions[0].lang : 'unknown',\n            testCases: testCases,\n            timestamp: new Date().toISOString(),\n            url: window.location.href,\n        };\n        return { success: true, testCase: testCaseData };\n    }\n    catch (error) {\n        void error; // Acknowledge unused variable\n        console.error('Error extracting test cases:', error);\n        return { success: false, message: 'Error extracting test cases', error: String(error) };\n    }\n}\n// Send code run data to backend via background script (to avoid CORS)\nasync function sendCodeRunToBackend(_version) {\n    void _version; // Acknowledge unused parameter\n    // No longer sending code runs to backend - only tracking accepted submissions\n    console.log(\"DSA Tracker: Code runs are no longer tracked\");\n    // Function kept for compatibility with existing code\n}\n// Send submission data to backend via background script\nasync function sendSubmissionToBackend(version) {\n    try {\n        // Instead of direct fetch, send message to background script\n        chrome.runtime.sendMessage({\n            action: 'sendSubmission',\n            data: {\n                problemId: version.problemId,\n                code: version.code,\n                language: version.language,\n                status: version.status,\n                executionTime: version.executionTime || null,\n                memoryUsed: version.memoryUsed || null,\n                externalId: version.submissionId || null,\n                errorMessage: version.errorMessage || null,\n                errorAnalysis: version.errorAnalysis || null\n            }\n        }, (response) => {\n            if (response && response.success) {\n                console.log(\"DSA Tracker: Successfully sent submission to backend via background script\");\n            }\n            else {\n                console.log(\"DSA Tracker: Failed to send submission to backend\", response?.error || \"Unknown error\");\n            }\n        });\n    }\n    catch (error) {\n        void error; // Acknowledge unused variable\n        console.error(\"DSA Tracker: Error sending submission to backend\", error);\n    }\n}\n// Helper function to get problem ID from URL\nfunction getProblemIdFromUrl(url) {\n    const match = url.match(/\\/problems\\/([^/]+)/);\n    return match ? match[1] : null;\n}\n// Helper class for error analysis\nclass ErrorAnalyzer {\n    analyzeError(params) {\n        return analyzeError('error', // status\n        params.errorMessage, params.code, params.language, params.failedTestCase, // input\n        undefined, // expected output\n        undefined, // actual output\n        params.problemId, params.problemTitle, undefined // difficulty\n        );\n    }\n}\n// Store version in local storage\nasync function storeVersionInStorage(version) {\n    await storeSolutionVersion(version.problemId, version);\n}\n// Get versions from local storage\nasync function getVersionsFromStorage(problemId) {\n    return await loadSolutionVersions(problemId);\n}\n// Get problem details from the DOM\nasync function getProblemDetailsFromDOM() {\n    // Try multiple selectors to find the problem title\n    const titleElement = document.querySelector('div[data-cy=\"question-title\"]') ||\n        document.querySelector('.css-v3d350') ||\n        document.querySelector('.question-title') ||\n        document.querySelector('h4.mb-4') || // New selector\n        document.querySelector('.text-title-large') || // New selector\n        document.querySelector('h4[data-track-load=\"description_content\"]'); // Another possible selector\n    if (titleElement) {\n        problemTitle = titleElement.textContent?.trim() || '';\n        console.log(\"DSA Tracker: Found problem title:\", problemTitle);\n    }\n    else {\n        // Try alternative approach - look for title in the document title\n        const docTitle = document.title;\n        if (docTitle && docTitle.includes('-')) {\n            problemTitle = docTitle.split('-')[0].trim();\n            console.log(\"DSA Tracker: Extracted problem title from document title:\", problemTitle);\n        }\n        else {\n            console.warn(\"DSA Tracker: Could not find problem title element\");\n        }\n    }\n    // Extract problem ID from URL\n    const urlMatch = window.location.pathname.match(/problems\\/([^/]+)/);\n    if (urlMatch && urlMatch[1]) {\n        problemId = urlMatch[1];\n        console.log(\"DSA Tracker: Extracted problem ID from URL:\", problemId);\n    }\n    else {\n        console.warn(\"DSA Tracker: Could not extract problem ID from URL\");\n        // Try to get problem ID from breadcrumb or other elements\n        const breadcrumbElement = document.querySelector('.breadcrumb');\n        if (breadcrumbElement) {\n            const text = breadcrumbElement.textContent || '';\n            const match = text.match(/(\\d+)\\.\\s/);\n            if (match && match[1]) {\n                problemId = match[1];\n                console.log(\"DSA Tracker: Extracted problem ID from breadcrumb:\", problemId);\n            }\n        }\n    }\n}\n// Initialize storage service\nasync function initializeStorageService() {\n    try {\n        // Any initialization needed for storage\n        console.log(\"DSA Tracker: Storage service initialized\");\n    }\n    catch (error) {\n        void error; // Acknowledge unused variable\n        console.error(\"DSA Tracker: Error initializing storage service:\", error);\n    }\n}\n// Add debug mode function \nfunction setupDebugMode() {\n    console.log(\"%cDSA Tracker: Advanced Debug Mode Activated\", \"color: blue; font-weight: bold; font-size: 14px\");\n    // 1. FETCH DEBUG - Log all fetch calls with full details\n    const origFetch = window.fetch;\n    window.fetch = async function (input, init) {\n        const url = typeof input === 'string' ? input : input instanceof Request ? input.url : String(input);\n        const method = init?.method || 'GET';\n        console.log(`%cDSA-DEBUG FETCH: ${method} ${url}`, 'color: red; font-weight: bold');\n        if (init?.body) {\n            try {\n                const bodyContent = typeof init.body === 'string'\n                    ? init.body\n                    : init.body instanceof FormData\n                        ? '[FormData]'\n                        : JSON.stringify(init.body);\n                console.log(`%cDSA-DEBUG BODY: ${bodyContent.substring(0, 500)}`, 'color: purple');\n            }\n            catch (e) {\n                void e; // Acknowledge unused variable\n                console.log(`%cDSA-DEBUG BODY: [Could not stringify]`, 'color: purple');\n            }\n        }\n        // Especially look for Run-related URLs\n        if (url.includes('interpret') || url.includes('solution') || url.includes('run')) {\n            console.log(`%cPOTENTIAL RUN REQUEST DETECTED: ${url}`, 'color: red; background: yellow; font-size: 14px');\n        }\n        const response = await origFetch.apply(this, [input, init]);\n        // Debug response for run-related requests\n        if (url.includes('interpret') || url.includes('solution') || url.includes('run')) {\n            response.clone().text().then(text => {\n                try {\n                    console.log(`%cRUN RESPONSE:`, 'color: blue; background: yellow; font-size: 14px', text.substring(0, 500) + (text.length > 500 ? '...' : ''));\n                }\n                catch (e) {\n                    void e; // Acknowledge unused variable\n                    console.log(`%cRUN RESPONSE: [Could not display]`, 'color: blue');\n                }\n            }).catch(err => {\n                console.log(`%cRUN RESPONSE ERROR: ${err}`, 'color: red');\n            });\n        }\n        return response;\n    };\n    // 2. BUTTON CLICK DEBUG - Find all potential Run buttons\n    function findRunButtons() {\n        // Using multiple selectors to find run buttons\n        const buttonSelectors = [\n            'button[data-cy=\"run-code-btn\"]',\n            'button[title=\"Run\"]',\n            'button[title*=\"un\"]'\n        ];\n        buttonSelectors.forEach(selector => {\n            try {\n                const buttons = document.querySelectorAll(selector);\n                buttons.forEach(btn => {\n                    if (!btn.hasAttribute('dsa-tracked')) {\n                        btn.setAttribute('dsa-tracked', 'true');\n                        console.log(`%cDSA-DEBUG Found Run Button with selector \"${selector}\":`, 'color: green; font-weight: bold', btn);\n                        btn.addEventListener('click', () => {\n                            console.log(`%cDSA-DEBUG Run Button CLICKED!`, 'color: green; background: yellow; font-size: 14px');\n                            // Capture code right after click\n                            setTimeout(captureCurrentCode, 100);\n                        });\n                    }\n                });\n            }\n            catch (e) {\n                void e; // Acknowledge unused variable\n                // Some selectors might not be valid, ignore errors\n            }\n        });\n        // Specifically look for the Monaco editor run button which might be different\n        const monacoButtons = document.querySelectorAll('.monaco-editor-container .action-item');\n        monacoButtons.forEach(btn => {\n            if (!btn.hasAttribute('dsa-tracked') &&\n                (btn.textContent?.includes('Run') ||\n                    btn.getAttribute('title')?.includes('Run'))) {\n                btn.setAttribute('dsa-tracked', 'true');\n                console.log(`%cDSA-DEBUG Found Monaco Run Button:`, 'color: green; font-weight: bold', btn);\n                btn.addEventListener('click', () => {\n                    console.log(`%cDSA-DEBUG Monaco Run Button CLICKED!`, 'color: green; background: yellow; font-size: 14px');\n                    setTimeout(captureCurrentCode, 100);\n                });\n            }\n        });\n    }\n    // 3. Monitor for DOM changes to detect new buttons\n    const observer = new MutationObserver(() => {\n        findRunButtons();\n    });\n    observer.observe(document.body, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: ['class', 'data-cy']\n    });\n    // Initial button scan\n    findRunButtons();\n    // 4. Try to capture code from editor\n    function captureCurrentCode() {\n        // Try different methods to get code\n        let code = '';\n        // Method 1: Check if Monaco editor exists\n        const monaco = window.monaco;\n        if (monaco && monaco.editor) {\n            try {\n                const editors = monaco.editor.getEditors();\n                if (editors?.length > 0) {\n                    code = editors[0].getValue();\n                    console.log(`%cDSA-DEBUG Captured code from Monaco editor (${code.length} chars)`, 'color: blue');\n                }\n            }\n            catch (err) {\n                void err; // Acknowledge unused variable\n                // Ignore errors\n            }\n        }\n        // Method 2: Try to find CodeMirror\n        if (!code) {\n            const cmElement = document.querySelector('.CodeMirror');\n            if (cmElement && cmElement.CodeMirror) {\n                code = cmElement.CodeMirror.getValue();\n                console.log(\"DSA Tracker: Got code from CodeMirror\", code.length);\n            }\n        }\n        // Try CodeMirror if Monaco failed\n        if (!code) {\n            const cmElement = document.querySelector('.CodeMirror');\n            if (cmElement && cmElement.CodeMirror) {\n                try {\n                    code = cmElement.CodeMirror.getValue();\n                }\n                catch (e) {\n                    console.log(\"DSA Tracker: Error getting code from CodeMirror\", e);\n                }\n            }\n        }\n        // Method 3: Try to find textarea elements that might contain code\n        if (!code) {\n            const textareas = document.querySelectorAll('textarea.inputarea');\n            if (textareas.length > 0) {\n                const textarea = textareas[0];\n                code = textarea.value;\n                console.log(`%cDSA-DEBUG Captured code from textarea (${code.length} chars)`, 'color: blue');\n            }\n        }\n        if (code) {\n            console.log(`%cCaptured code snippet:`, 'color: blue', code.substring(0, 100) + '...');\n        }\n        else {\n            console.log(`%cDSA-DEBUG Could not capture code from any editor`, 'color: red');\n        }\n    }\n    // 5. Check for XMLHttpRequest usage (alternative to fetch)\n    const origXHROpen = XMLHttpRequest.prototype.open;\n    XMLHttpRequest.prototype.open = function (method, url, async = true, username, password) {\n        const urlStr = url.toString();\n        console.log(`%cDSA-DEBUG XHR: ${method} ${urlStr}`, 'color: orange; font-weight: bold');\n        // Especially look for Run-related URLs\n        if (urlStr.includes('interpret') || urlStr.includes('solution') || urlStr.includes('run')) {\n            console.log(`%cPOTENTIAL XHR RUN REQUEST DETECTED: ${urlStr}`, 'color: orange; background: yellow; font-size: 14px');\n            // Monitor this XHR\n            this.addEventListener('load', function () {\n                console.log(`%cRUN XHR RESPONSE:`, 'color: blue; background: yellow; font-size: 14px', this.responseText?.substring(0, 500));\n            });\n        }\n        return origXHROpen.call(this, method, url, async, username, password);\n    };\n    console.log(\"%cDSA Tracker: Debug Mode Setup Complete\", \"color: blue; font-weight: bold\");\n}\n// Instead of defining the cleanup function inside, we'll use a module-level variable\nlet visualTrackingIntervals = [];\nfunction setupVisualRunTracking() {\n    console.log(\"DSA Tracker: Setting up visual run tracking\");\n    // Track elements that signal a code run is in progress\n    let runInProgress = false;\n    let lastRunTimestamp = 0;\n    // Updated selectors for run buttons based on current LeetCode UI\n    const runButtonSelectors = [\n        '[data-cy=\"run-code-btn\"]',\n        'button[title=\"Run\"]',\n        'button[title=\"Run Code\"]',\n        'button[data-e2e-locator=\"console-run-button\"]',\n        'button.runcode-wrapper__run-btn',\n        '.monaco-editor button.codicon-play',\n        '.monaco-action-bar .actions-container .action-item',\n        '.btn-success',\n        '.ant-btn-primary',\n        '.submit__2ISl'\n    ];\n    // Function to check if an element is a Run button by its text content or attributes\n    function isRunButton(element) {\n        // Check text content\n        const text = element.textContent?.toLowerCase() || '';\n        if (text.includes('run') || text.includes('execute') || text.includes('test')) {\n            return true;\n        }\n        // Check aria-label\n        const ariaLabel = element.getAttribute('aria-label')?.toLowerCase() || '';\n        if (ariaLabel.includes('run') || ariaLabel.includes('execute') || ariaLabel.includes('test')) {\n            return true;\n        }\n        // Check for common class names and attributes\n        const className = element.className;\n        if ((typeof className === 'string' && (className.includes('run') ||\n            className.includes('execute') ||\n            className.includes('play'))) ||\n            element.getAttribute('data-cy')?.includes('run') ||\n            element.getAttribute('data-test')?.includes('run')) {\n            return true;\n        }\n        return false;\n    }\n    // Function to check for active Run indicators with updated selectors\n    function checkForRunIndicators() {\n        // Look for typical loading indicators that appear during a run\n        const loadingIndicators = [\n            '.ant-spin-spinning',\n            '.loading-indicator',\n            '.spinner',\n            '.executing-indicator',\n            '[role=\"progressbar\"]',\n            '.testcase-loading',\n            '.preloader__Preloader',\n            '.jsx-ProgressCircle',\n            'div[class*=\"loading\"]',\n            'div[class*=\"spinner\"]'\n        ];\n        for (const selector of loadingIndicators) {\n            try {\n                const indicator = document.querySelector(selector);\n                if (indicator && indicator.offsetParent !== null) {\n                    // Visible loading indicator found\n                    if (!runInProgress) {\n                        // This is a new run starting\n                        runInProgress = true;\n                        lastRunTimestamp = Date.now();\n                        console.log(\"DSA Tracker: Run detected via loading indicator\", selector);\n                        // Capture code from editor\n                        setTimeout(() => captureCodeAfterRunDetection(), 100);\n                    }\n                    return;\n                }\n            }\n            catch (error) {\n                void error; // Acknowledge unused variable\n                // Ignore errors from invalid selectors\n            }\n        }\n        // Also check for result panels that appear after a run\n        const resultSelectors = [\n            '.result__23wN',\n            '.result-container',\n            '[data-e2e-locator=\"console-result-container\"]',\n            'div[class*=\"result\"]',\n            '.testcase-result'\n        ];\n        let resultPanelFound = false;\n        for (const selector of resultSelectors) {\n            try {\n                const resultPanel = document.querySelector(selector);\n                if (resultPanel && resultPanel.offsetParent !== null) {\n                    resultPanelFound = true;\n                    // If we were tracking a run and now see results, log it\n                    if (runInProgress && Date.now() - lastRunTimestamp > 500) {\n                        console.log(\"DSA Tracker: Run result panel found\", selector);\n                        // Don't reset runInProgress yet, wait for the next cycle\n                    }\n                    break;\n                }\n            }\n            catch (error) {\n                void error; // Acknowledge unused variable\n                // Ignore errors from invalid selectors\n            }\n        }\n        // No loading indicators found, check if we need to reset\n        if (runInProgress && Date.now() - lastRunTimestamp > 5000 && !resultPanelFound) {\n            // It's been 5 seconds since we detected a run in progress\n            // and no loading indicators are visible anymore\n            runInProgress = false;\n            console.log(\"DSA Tracker: Run appears to have completed\");\n        }\n    }\n    // Set up a DOM observer to watch for Run button activity\n    const observer = new MutationObserver((mutations) => {\n        // Check if any mutations involve Run buttons\n        for (const mutation of mutations) {\n            if (mutation.type === 'attributes' &&\n                mutation.target instanceof HTMLElement) {\n                const target = mutation.target;\n                // Check if this is a Run button changing state (like becoming disabled during a run)\n                let isTargetRunButton = false;\n                // First check if it matches one of our selectors\n                for (const selector of runButtonSelectors) {\n                    try {\n                        if (target.matches(selector)) {\n                            // For general button selectors, additional check may be needed\n                            isTargetRunButton = isRunButton(target);\n                            break;\n                        }\n                    }\n                    catch (e) {\n                        void e; // Acknowledge unused variable\n                        // Ignore invalid selector errors\n                    }\n                }\n                if (isTargetRunButton) {\n                    // Cast to HTMLButtonElement if it's a button\n                    const isDisabled = target instanceof HTMLButtonElement ?\n                        (target.disabled || target.hasAttribute('disabled')) :\n                        target.hasAttribute('disabled');\n                    console.log(\"DSA Tracker: Run button state changed\", {\n                        disabled: isDisabled,\n                        className: target.className\n                    });\n                    // If button was just disabled, it likely means a run started\n                    if (isDisabled && !runInProgress) {\n                        runInProgress = true;\n                        lastRunTimestamp = Date.now();\n                        setTimeout(() => captureCodeAfterRunDetection(), 100);\n                    }\n                }\n            }\n            // Also look for new loading indicators that might have appeared\n            if (mutation.type === 'childList') {\n                checkForRunIndicators();\n            }\n        }\n    });\n    // Start observing the entire document for button state changes\n    observer.observe(document.body, {\n        attributes: true,\n        attributeFilter: ['disabled', 'class'],\n        childList: true,\n        subtree: true\n    });\n    // Store intervals in the module-level array\n    const checkInterval = setInterval(checkForRunIndicators, 1000);\n    visualTrackingIntervals.push(checkInterval);\n    // Initial check for run buttons to monitor\n    function findRunButtons() {\n        for (const selector of runButtonSelectors) {\n            try {\n                const buttons = document.querySelectorAll(selector);\n                buttons.forEach(button => {\n                    // For general selectors, check text content\n                    let isRun = true;\n                    if (selector === 'button' ||\n                        selector === '.ant-btn' ||\n                        selector === '.ant-btn-primary' ||\n                        selector.includes('action-item')) {\n                        isRun = isRunButton(button);\n                    }\n                    if (isRun) {\n                        // console.log(\"DSA Tracker: Found run button\", selector, button);\n                        // Add direct click listener\n                        if (!button.hasAttribute('dsa-tracker-monitored')) {\n                            button.setAttribute('dsa-tracker-monitored', 'true');\n                            button.addEventListener('click', () => {\n                                console.log(\"DSA Tracker: Run button clicked directly\");\n                                runInProgress = true;\n                                lastRunTimestamp = Date.now();\n                                setTimeout(() => captureCodeAfterRunDetection(), 100);\n                            });\n                        }\n                    }\n                });\n            }\n            catch (e) {\n                void e; // Acknowledge unused variable\n                // Ignore invalid selector errors\n            }\n        }\n    }\n    // Run the initial button finder\n    findRunButtons();\n    // Also check periodically for new buttons\n    const buttonCheckInterval = setInterval(findRunButtons, 3000);\n    visualTrackingIntervals.push(buttonCheckInterval);\n    console.log(\"DSA Tracker: Visual run tracking setup complete\");\n}\n// Modify the injectRunInterception function\nfunction injectRunInterception() {\n    console.log(\"DSA Tracker: Setting up run interception with CSP-safe method\");\n    // Observe the DOM for Monaco editor being added\n    const editorObserver = new MutationObserver(() => {\n        // Check if Monaco editor has been added to the page\n        const monacoElement = document.querySelector('.monaco-editor');\n        if (monacoElement) {\n            console.log(\"DSA Tracker: Monaco editor detected\");\n            // Poll for the editor object to be available in window\n            const checkForMonaco = setInterval(() => {\n                // Check if monaco is available on window\n                if (window.monaco && window.monaco.editor) {\n                    clearInterval(checkForMonaco);\n                    isMonacoReady = true; // Set global flag\n                    console.log(\"DSA Tracker: Monaco editor API available, setting up monitoring\");\n                    // Monitor for editor changes\n                    try {\n                        const editors = window.monaco.editor.getEditors();\n                        if (editors && editors.length > 0) {\n                            const editor = editors[0];\n                            // Hook into editor change events to detect modifications\n                            if (editor.onDidChangeModelContent) {\n                                editor.onDidChangeModelContent((event) => {\n                                    void event; // Acknowledge unused variable\n                                    console.log(\"DSA Tracker: Editor content changed\");\n                                });\n                            }\n                            console.log(\"DSA Tracker: Successfully set up Monaco editor monitoring\");\n                        }\n                    }\n                    catch (e) {\n                        void e; // Acknowledge unused variable\n                        console.error(\"DSA Tracker: Error setting up Monaco monitoring\", e);\n                    }\n                }\n            }, 1000);\n            // Safety cleanup - don't poll forever\n            setTimeout(() => {\n                clearInterval(checkForMonaco);\n                if (!isMonacoReady) {\n                    console.log(\"DSA Tracker: Monaco detection timed out after 30 seconds\");\n                }\n            }, 30000);\n        }\n    });\n    // Start observing for editor\n    editorObserver.observe(document.body, {\n        childList: true,\n        subtree: true\n    });\n    console.log(\"DSA Tracker: Page script injection setup complete (CSP-safe method)\");\n}\n// Add DOM events monitoring to capture key user interactions\nfunction monitorDomEvents() {\n    console.log(\"DSA Tracker: Setting up DOM events monitoring\");\n    // Listen for keypress events that might indicate Run action (Ctrl+Enter is common)\n    document.addEventListener('keydown', (e) => {\n        // Check for Ctrl+Enter, which is often used to run code\n        if (e.ctrlKey && e.key === 'Enter') {\n            console.log(\"DSA Tracker: Detected Ctrl+Enter shortcut, likely a code run\");\n            // Wait a short time for the run to start, then capture code\n            setTimeout(() => {\n                // Try to get code from the active editor\n                const code = getCurrentCode();\n                if (code) {\n                    handleCodeRun(code, currentLanguage);\n                }\n            }, 100);\n        }\n    });\n    // Function to get current code from any available editor\n    function getCurrentCode() {\n        let code = '';\n        // Try Monaco editor first using our helper\n        const editors = getMonacoEditors();\n        if (editors) {\n            try {\n                code = editors[0].getValue();\n            }\n            catch (e) {\n                void e; // Acknowledge unused variable\n                console.log(\"DSA Tracker: Error getting code from Monaco\", e);\n            }\n        }\n        // Try CodeMirror if Monaco failed\n        if (!code) {\n            const cmElement = document.querySelector('.CodeMirror');\n            if (cmElement && cmElement.CodeMirror) {\n                try {\n                    code = cmElement.CodeMirror.getValue();\n                }\n                catch (e) {\n                    void e; // Acknowledge unused variable\n                    console.log(\"DSA Tracker: Error getting code from CodeMirror\", e);\n                }\n            }\n        }\n        // Try textareas as last resort\n        if (!code) {\n            const textareas = document.querySelectorAll('textarea');\n            for (const textarea of textareas) {\n                if (textarea.value && textarea.value.length > 20) {\n                    code = textarea.value;\n                    break;\n                }\n            }\n        }\n        return code;\n    }\n    console.log(\"DSA Tracker: DOM events monitoring setup complete\");\n}\n// Define cleanup function at module level\nfunction cleanupVisualTracking() {\n    console.log(\"DSA Tracker: Cleaning up visual run tracking\");\n    visualTrackingIntervals.forEach(interval => clearInterval(interval));\n    visualTrackingIntervals = [];\n}\n// Add a cleanup listener to ensure intervals are cleared when the extension is unloaded\nwindow.addEventListener('beforeunload', () => {\n    cleanupVisualTracking();\n});\n// Add this function to handle code runs when detected\nfunction handleCodeRun(code, language) {\n    console.log(`DSA Tracker: Code run detected - ${code.length} chars, language: ${language}`);\n    // No longer tracking code runs - only tracking accepted submissions via fetch interceptor\n    // This function is kept as a placeholder to maintain compatibility with existing code\n}\n// Add a function to get code from Monaco using the background script\nasync function getMonacoCodeCSPSafe() {\n    return new Promise((resolve) => {\n        try {\n            // Set up retry mechanism with backoff\n            let retries = 0;\n            const maxRetries = 3;\n            const attemptToGetCode = () => {\n                console.log(`DSA Tracker: Attempting to get Monaco code (attempt ${retries + 1}/${maxRetries})`);\n                // Create a one-time message to get the code\n                chrome.runtime.sendMessage({\n                    action: 'get-monaco-code',\n                    tabId: tabId // Use the tab ID we stored\n                }, (response) => {\n                    if (chrome.runtime.lastError) {\n                        console.error(\"DSA Tracker: Error in message response:\", chrome.runtime.lastError);\n                        if (retries < maxRetries) {\n                            retries++;\n                            setTimeout(attemptToGetCode, 500 * retries); // Exponential backoff\n                        }\n                        else {\n                            resolve(null);\n                        }\n                        return;\n                    }\n                    if (response && response.code) {\n                        console.log(`DSA Tracker: Successfully got code from background script (${response.code.length} chars)`);\n                        console.log(\"DSA Tracker: Background script code content:\", response.code.substring(0, 200) + (response.code.length > 200 ? '...' : ''));\n                        // Log information about the source of the code if available\n                        if (response.source) {\n                            console.log(`DSA Tracker: Code was extracted using method: ${response.source}`);\n                        }\n                        resolve(response.code);\n                    }\n                    else {\n                        console.log(\"DSA Tracker: No code received from background script\", response);\n                        if (retries < maxRetries) {\n                            retries++;\n                            setTimeout(attemptToGetCode, 500 * retries); // Exponential backoff\n                        }\n                        else {\n                            resolve(null);\n                        }\n                    }\n                });\n            };\n            // Start the first attempt\n            attemptToGetCode();\n            // Set a timeout in case the message doesn't get a response\n            setTimeout(() => {\n                if (retries >= maxRetries) {\n                    console.log(\"DSA Tracker: Timed out waiting for Monaco code\");\n                    resolve(null);\n                }\n            }, 5000);\n        }\n        catch (error) {\n            console.error(\"DSA Tracker: Error getting Monaco code (CSP-safe)\", error);\n            resolve(null);\n        }\n    });\n}\n// Function to capture code when a run is detected\nasync function captureCodeAfterRunDetection() {\n    // Improved logging to better understand the Monaco state\n    console.log(\"DSA Tracker: Capturing code after run detection\", {\n        windowMonaco: window.monaco !== undefined,\n        hasEditor: window.monaco?.editor !== undefined,\n        hasGetEditors: typeof window.monaco?.editor?.getEditors === 'function',\n        monacoReady: isMonacoReady,\n        monacoElements: document.querySelectorAll('.monaco-editor').length\n    });\n    // Try to find the code editor\n    let code = '';\n    const language = currentLanguage;\n    try {\n        // Try to get code directly from Monaco API\n        if (window.monaco && window.monaco.editor && typeof window.monaco.editor.getEditors === 'function') {\n            const editors = window.monaco.editor.getEditors();\n            if (editors && editors.length > 0) {\n                code = editors[0].getValue();\n                console.log(\"DSA Tracker: Got code directly from Monaco API:\", code.substring(0, 200) + (code.length > 200 ? '...' : ''));\n                handleCodeRun(code, language);\n                return;\n            }\n        }\n        // If direct access fails, try using the background script (CSP-safe method)\n        console.log(\"DSA Tracker: Direct Monaco API access failed, trying background script\");\n        const cspSafeCode = await getMonacoCodeCSPSafe();\n        if (cspSafeCode) {\n            code = cspSafeCode;\n            console.log(\"DSA Tracker: Got code via CSP-safe method\", code.length);\n            console.log(\"DSA Tracker: CSP-safe code content:\", code.substring(0, 200) + (code.length > 200 ? '...' : ''));\n            handleCodeRun(code, language);\n            return;\n        }\n        // If both methods failed, log the failure\n        console.log(\"DSA Tracker: Failed to capture code from Monaco editor API\");\n    }\n    catch (err) {\n        console.error(\"DSA Tracker: Error capturing code\", err);\n    }\n}\n// Add this function to inject a script into the page context to access Monaco directly\n// Commented out as it causes CSP issues - using accessMonacoWithoutInlineScript instead\n/*\nfunction injectScriptToAccessMonaco() {\n  console.log(\"DSA Tracker: Injecting script to access Monaco directly\");\n  \n  // Create a script element to execute in the page's context\n  const script = document.createElement('script');\n  script.textContent = `\n    // This code runs in the page context with direct access to window.monaco\n    (function() {\n      function checkForMonaco() {\n        if (window.monaco && window.monaco.editor) {\n          console.log(\"MonacoDetected: Monaco editor found in page context\");\n          \n          // Create a custom event to notify our extension\n          const event = new CustomEvent('monaco-editor-detected', {\n            detail: { found: true }\n          });\n          document.dispatchEvent(event);\n          \n          // Set up a function to get code from Monaco when requested\n          window.getMonacoCode = function() {\n            try {\n              const editors = window.monaco.editor.getEditors();\n              if (editors && editors.length > 0) {\n                const code = editors[0].getValue();\n                return code;\n              }\n            } catch (e) {\n              console.error(\"Error getting Monaco code:\", e);\n            }\n            return null;\n          };\n          \n          // Create a function to listen for editor changes\n          window.setupMonacoChangeListener = function() {\n            try {\n              const editors = window.monaco.editor.getEditors();\n              if (editors && editors.length > 0) {\n                editors[0].onDidChangeModelContent((event) => {\n                  document.dispatchEvent(new CustomEvent('monaco-content-changed'));\n                });\n                return true;\n              }\n            } catch (e) {\n              console.error(\"Error setting up Monaco change listener:\", e);\n            }\n            return false;\n          };\n          \n          // Notify that we can get code\n          document.dispatchEvent(new CustomEvent('monaco-code-available'));\n          \n          // Try to set up the change listener\n          if (window.setupMonacoChangeListener()) {\n            console.log(\"MonacoDetected: Change listener set up successfully\");\n          }\n          \n          // No need to check anymore\n          clearInterval(checkInterval);\n        }\n      }\n      \n      // Check immediately\n      checkForMonaco();\n      \n      // And also set up an interval to check regularly\n      const checkInterval = setInterval(checkForMonaco, 1000);\n      \n      // Stop checking after 30 seconds to avoid memory leaks\n      setTimeout(() => {\n        clearInterval(checkInterval);\n      }, 30000);\n    })();\n  `;\n  \n  // Inject the script\n  (document.head || document.documentElement).appendChild(script);\n  \n  // Remove the script after injection (the code will continue to run)\n  script.remove();\n  \n  // Listen for the custom event from our injected script\n  document.addEventListener('monaco-editor-detected', (event) => {\n    console.log(\"DSA Tracker: Received monaco-editor-detected event\", (event as CustomEvent).detail);\n    isMonacoReady = true;\n  });\n  \n  // Listen for code availability\n  document.addEventListener('monaco-code-available', () => {\n    console.log(\"DSA Tracker: Monaco code retrieval is now available\");\n  });\n  \n  // Listen for content changes\n  document.addEventListener('monaco-content-changed', () => {\n    console.log(\"DSA Tracker: Monaco content changed\");\n  });\n}\n*/\n// Add this function to access Monaco editor using chrome.scripting API instead of inline script injection\nasync function accessMonacoWithoutInlineScript() {\n    console.log(\"DSA Tracker: Setting up Monaco access without inline scripts\");\n    try {\n        // Create a port for communication with the background script\n        const port = chrome.runtime.connect({ name: \"monaco-access\" });\n        // Set up listener for messages from the background script\n        port.onMessage.addListener((message) => {\n            if (message.action === 'monaco-detected') {\n                console.log(\"DSA Tracker: Background script detected Monaco editor\");\n                isMonacoReady = true;\n            }\n            else if (message.action === 'monaco-code') {\n                console.log(\"DSA Tracker: Received code from background script\", message.code?.length || 0);\n                if (message.code) {\n                    handleCodeRun(message.code, currentLanguage);\n                }\n            }\n        });\n        // Listen for button clicks to request code\n        document.addEventListener('click', (event) => {\n            const target = event.target;\n            if (target.matches('button') &&\n                (target.textContent?.toLowerCase().includes('run') ||\n                    target.getAttribute('aria-label')?.toLowerCase().includes('run'))) {\n                console.log(\"DSA Tracker: Run button clicked, requesting code from background\");\n                // Delay slightly to let the code update in the editor\n                setTimeout(() => {\n                    port.postMessage({ action: 'get-monaco-code' });\n                }, 100);\n            }\n        }, true);\n        // Request Monaco detection\n        port.postMessage({ action: 'detect-monaco' });\n    }\n    catch (error) {\n        console.error(\"DSA Tracker: Error setting up Monaco access without inline scripts\", error);\n    }\n}\n// Store the tab ID for later use\nlet tabId;\n// Update the initialization function to include the tab ID detection\nfunction initTabId() {\n    chrome.runtime.sendMessage({ action: 'get-tab-id' }, (response) => {\n        if (response && response.tabId) {\n            tabId = response.tabId;\n            console.log(\"DSA Tracker: Got tab ID:\", tabId);\n        }\n    });\n}\n// Update the main initialization function to include our new approaches\nasync function initializeExtension() {\n    console.log(\"DSA Tracker: Initializing extension on LeetCode\");\n    try {\n        // Setup debug mode first to catch everything\n        setupDebugMode();\n        // Get the tab ID for communication with background script\n        initTabId();\n        // Set up all our interception approaches (redundancy is good!)\n        // 1. Use CSP-safe Monaco access via the background script\n        // This is the primary approach that works with strict CSP policies\n        accessMonacoWithoutInlineScript();\n        // 2. Try the CSP-safe script injection method\n        injectRunInterception();\n        // 3. Set up visual run tracking for button/UI based detection\n        setupVisualRunTracking();\n        // 4. Monitor DOM events for keyboard shortcuts and other interactions\n        monitorDomEvents();\n        // Load problem ID and title\n        await getProblemDetailsFromDOM();\n        // Initialize storage service\n        await initializeStorageService();\n        // 5. Set up network interception for code runs and submissions\n        setupNetworkInterception();\n        // Add debug information to help troubleshoot\n        console.log(\"DSA Tracker: Extension initialized with:\", {\n            problemId: problemId,\n            problemTitle: problemTitle,\n            url: window.location.href,\n            networkInterceptionActive: true,\n            pageScriptInjected: true,\n            visualTrackingActive: true,\n            domEventsMonitored: true,\n            usingCSPSafeApproach: true\n        });\n        // Add a visible indicator during development to confirm the extension is running\n        const isDevelopment = true; // Set manually for now\n        if (isDevelopment) {\n            const indicator = document.createElement('div');\n            indicator.style.position = 'fixed';\n            indicator.style.bottom = '10px';\n            indicator.style.right = '10px';\n            indicator.style.padding = '5px 10px';\n            indicator.style.background = 'rgba(0, 128, 0, 0.7)';\n            indicator.style.color = 'white';\n            indicator.style.borderRadius = '4px';\n            indicator.style.fontSize = '12px';\n            indicator.style.zIndex = '9999';\n            indicator.textContent = 'DSA Tracker Active (CSP-Safe)';\n            document.body.appendChild(indicator);\n        }\n    }\n    catch (error) {\n        void error; // Acknowledge unused variable\n        console.error(\"DSA Tracker: Error initializing extension:\", error);\n    }\n}\n// Check if page is a LeetCode problem page and initialize\nfunction checkIfLeetCodeProblemPage() {\n    // Check if URL matches a LeetCode problem page pattern\n    const isProblemPage = window.location.href.includes('leetcode.com/problems/') ||\n        document.querySelector('[data-cy=\"question-title\"]') !== null ||\n        document.querySelector('.question-title') !== null;\n    if (isProblemPage) {\n        console.log(\"DSA Tracker: Detected LeetCode problem page\");\n        // Wait for page to fully load\n        if (document.readyState === 'complete') {\n            initializeExtension();\n        }\n        else {\n            window.addEventListener('load', initializeExtension);\n        }\n    }\n    else {\n        console.log(\"DSA Tracker: Not a LeetCode problem page, extension not initialized\");\n    }\n}\n// Start the extension initialization process\ncheckIfLeetCodeProblemPage();\n// Also initialize when page URL changes (for SPA navigation)\nlet lastUrl = window.location.href;\nnew MutationObserver(() => {\n    if (lastUrl !== window.location.href) {\n        lastUrl = window.location.href;\n        console.log(\"DSA Tracker: URL changed, checking if it's a problem page\");\n        checkIfLeetCodeProblemPage();\n    }\n}).observe(document, { subtree: true, childList: true });\n"],"names":[],"sourceRoot":""}