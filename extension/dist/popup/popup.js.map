{"version":3,"file":"popup/popup.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://extension/./lib/storage.ts","webpack://extension/webpack/bootstrap","webpack://extension/webpack/runtime/define property getters","webpack://extension/webpack/runtime/hasOwnProperty shorthand","webpack://extension/webpack/runtime/make namespace object","webpack://extension/./popup/popup.ts"],"sourcesContent":["// Storage keys\nconst AUTH_KEY = 'dsa_tracker_auth';\n// @ts-expect-error - process.env.API_BASE_URL is injected by webpack.DefinePlugin\nconst API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';\n// Storage API wrapper\nclass StorageService {\n    // Auth methods\n    async saveAuth(authData) {\n        return chrome.storage.local.set({ [AUTH_KEY]: authData });\n    }\n    async getAuth() {\n        const result = await chrome.storage.local.get(AUTH_KEY);\n        return result[AUTH_KEY] || null;\n    }\n    async updateAuth(authData) {\n        const currentAuth = await this.getAuth();\n        if (!currentAuth)\n            return this.saveAuth(authData);\n        return this.saveAuth({\n            ...currentAuth,\n            ...authData\n        });\n    }\n    async clearAuth() {\n        return chrome.storage.local.remove(AUTH_KEY);\n    }\n    // Network status methods\n    async getOnlineStatus() {\n        try {\n            const response = await fetch('https://www.google.com', { method: 'HEAD', mode: 'no-cors' });\n            return response.type === 'opaque' || response.ok;\n        }\n        catch {\n            // Ignore error and return offline status\n            return false;\n        }\n    }\n    async setOnlineStatus(isOnline) {\n        // This is now just a no-op since we don't store this in local storage\n        console.log(`Online status set to: ${isOnline}`);\n    }\n    // Problem methods - Direct API communication\n    async getProblems() {\n        // Return empty array as we don't store locally anymore\n        return [];\n    }\n    async addProblem(problem) {\n        const authData = await this.getAuth();\n        if (!authData) {\n            console.error('Not authenticated, cannot add problem');\n            return;\n        }\n        try {\n            const isOnline = await this.getOnlineStatus();\n            if (!isOnline) {\n                console.log('Offline: Cannot add problem, no local storage available');\n                return;\n            }\n            // Send directly to API\n            await fetch(`${API_BASE_URL}/api/problems`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${authData.token}`\n                },\n                body: JSON.stringify(problem)\n            });\n        }\n        catch (error) {\n            console.error('Error adding problem:', error);\n        }\n    }\n    // Submission methods - Direct API communication\n    async getSubmissions() {\n        // Return empty array as we don't store locally anymore\n        return [];\n    }\n    async getPendingSubmissions() {\n        // Return empty array as we don't store locally anymore\n        return [];\n    }\n    async addSubmission(submission) {\n        const authData = await this.getAuth();\n        if (!authData) {\n            console.error('Not authenticated, cannot add submission');\n            return submission;\n        }\n        try {\n            const isOnline = await this.getOnlineStatus();\n            if (!isOnline) {\n                console.log('Offline: Cannot add submission, no local storage available');\n                return submission;\n            }\n            // Send directly to API\n            const response = await fetch(`${API_BASE_URL}/api/submissions`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${authData.token}`\n                },\n                body: JSON.stringify(submission)\n            });\n            if (response.ok) {\n                const result = await response.json();\n                return result;\n            }\n        }\n        catch (error) {\n            console.error('Error adding submission:', error);\n        }\n        return submission;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async updateSubmissionStatus(_id, _syncStatus) {\n        // No-op as we don't store locally anymore\n    }\n    // Error methods - Direct API communication\n    async getPendingErrors() {\n        // Return empty array as we don't store locally anymore\n        return [];\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async updateErrorStatus(_id, _status) {\n        // No-op as we don't store locally anymore\n    }\n    // Test case methods - Direct API communication\n    async getPendingTestCases() {\n        // Return empty array as we don't store locally anymore\n        return [];\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async updateTestCaseStatus(_id, _status) {\n        // No-op as we don't store locally anymore\n    }\n    // Bug report methods - Direct API communication\n    async getBugs() {\n        // Return empty array as we don't store locally anymore\n        return [];\n    }\n    // Sync timestamp methods\n    async updateSyncTimestamp() {\n        // No-op as we don't store locally anymore\n    }\n    // Helper method to clear all storage (only used for debugging/reset)\n    async clearAll() {\n        return chrome.storage.local.clear();\n    }\n}\n// Export singleton instance\nexport const storageService = new StorageService();\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { storageService } from '../lib/storage';\n// Add a configurable API URL that can be updated easily\n// @ts-expect-error - process.env.API_BASE_URL is injected by webpack.DefinePlugin\nconst API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';\ndocument.addEventListener('DOMContentLoaded', async () => {\n    const loginSection = document.getElementById('login-section');\n    const problemSection = document.getElementById('problem-section');\n    const connectionStatus = document.getElementById('connection-status');\n    const loginForm = document.getElementById('login-form');\n    const loginError = document.getElementById('login-error');\n    const logoutBtn = document.getElementById('logout-btn');\n    const trackBtn = document.getElementById('track-btn');\n    const actionStatus = document.getElementById('action-status');\n    const errorPatternsBtn = document.getElementById('error-patterns-btn');\n    // Check if user is logged in\n    const authData = await storageService.getAuth();\n    if (authData && isTokenValid(authData)) {\n        showLoggedInState(authData);\n    }\n    else {\n        showLoggedOutState();\n    }\n    // Handle login form submission\n    loginForm?.addEventListener('submit', async (e) => {\n        e.preventDefault();\n        const emailInput = document.getElementById('email');\n        const passwordInput = document.getElementById('password');\n        if (!emailInput || !passwordInput)\n            return;\n        const email = emailInput.value;\n        const password = passwordInput.value;\n        if (!email || !password) {\n            if (loginError)\n                loginError.textContent = 'Please enter both email and password';\n            return;\n        }\n        try {\n            // Show loading status\n            if (loginError)\n                loginError.textContent = 'Logging in...';\n            // Call the API to authenticate\n            const response = await fetch(`${API_BASE_URL}/api/extension/login`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Client-Info': 'dsa-tracker-extension/1.0.0' // Supabase client info\n                },\n                body: JSON.stringify({ email, password }),\n                credentials: 'same-origin' // Changed from 'include' to 'same-origin'\n            });\n            // Get the response data\n            const data = await response.json();\n            if (!response.ok) {\n                throw new Error(data.error || data.message || 'Login failed. Check your credentials.');\n            }\n            console.log('Login successful:', data);\n            // Check if we have the expected data structure\n            if (!data.token || !data.user || !data.user.id) {\n                throw new Error('Invalid response from server');\n            }\n            // Extract and store all cookies from the response\n            const cookies = {};\n            // The Headers.getAll method is not available in all browsers,\n            // so we need to handle both cases\n            let setCookieHeaders = [];\n            const cookieHeader = response.headers.get('set-cookie');\n            if (cookieHeader) {\n                setCookieHeaders = [cookieHeader];\n            }\n            if (setCookieHeaders && setCookieHeaders.length > 0) {\n                console.log('Got cookies from login response:', setCookieHeaders);\n                // Parse the cookies\n                for (const cookieStr of setCookieHeaders) {\n                    if (!cookieStr)\n                        continue;\n                    const cookieParts = cookieStr.split(';')[0].split('=');\n                    if (cookieParts.length >= 2) {\n                        const name = cookieParts[0].trim();\n                        const value = cookieParts.slice(1).join('=').trim();\n                        cookies[name] = value;\n                    }\n                }\n            }\n            // Create cookie string for future requests\n            let cookieString = '';\n            for (const [name, value] of Object.entries(cookies)) {\n                cookieString += `${name}=${value}; `;\n            }\n            // Check for Supabase auth cookies (for debugging purposes)\n            const supabaseCookies = Object.keys(cookies).filter(name => name.startsWith('sb-') ||\n                name.startsWith('supabase-') ||\n                name.includes('auth-token'));\n            if (supabaseCookies.length > 0) {\n                console.log('Found Supabase auth cookies:', supabaseCookies);\n            }\n            else {\n                console.log('No Supabase auth cookies found, using token authentication');\n            }\n            console.log('Session cookies parsed:', Object.keys(cookies));\n            // Check for token in data.session for Supabase\n            let accessToken = data.token;\n            let refreshToken = data.refreshToken || '';\n            // Some Supabase implementations might include session data\n            if (data.session) {\n                if (data.session.access_token) {\n                    accessToken = data.session.access_token;\n                    console.log('Using access_token from session data');\n                }\n                if (data.session.refresh_token) {\n                    refreshToken = data.session.refresh_token;\n                    console.log('Using refresh_token from session data');\n                }\n            }\n            // Save auth data with cookies\n            await storageService.saveAuth({\n                token: accessToken,\n                refreshToken: refreshToken,\n                expiresAt: Date.now() + ((data.expiresIn || 3600) * 1000),\n                sessionCookie: cookieString, // Store all cookies\n                user: {\n                    id: data.user.id,\n                    email: data.user.email,\n                    name: data.user.name,\n                },\n            });\n            // Test the saved credentials immediately\n            try {\n                const testAuth = await storageService.getAuth();\n                console.log('Testing auth credentials...');\n                const testResponse = await fetch(`${API_BASE_URL}/api/user/me`, {\n                    method: 'GET',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': `Bearer ${testAuth?.token}`,\n                        'X-Client-Info': 'dsa-tracker-extension/1.0.0',\n                        'Cookie': testAuth?.sessionCookie || ''\n                    },\n                    credentials: 'same-origin'\n                });\n                if (testResponse.ok) {\n                    console.log('Auth test successful!');\n                }\n                else {\n                    console.warn('Auth test failed:', await testResponse.text());\n                    // Try to extract anon key and other details from page for debugging\n                    console.log('Attempting to extract Supabase config from backend...');\n                    const configResponse = await fetch(`${API_BASE_URL}/api/config`, {\n                        method: 'GET',\n                        credentials: 'same-origin'\n                    });\n                    if (configResponse.ok) {\n                        console.log('Config data:', await configResponse.json());\n                    }\n                }\n            }\n            catch (testError) {\n                console.warn('Auth test error:', testError);\n            }\n            // Get the saved auth data and confirm it was stored\n            const savedAuth = await storageService.getAuth();\n            if (!savedAuth || !savedAuth.token) {\n                throw new Error('Failed to save authentication data');\n            }\n            showLoggedInState(savedAuth);\n        }\n        catch (error) {\n            console.error('Login error:', error);\n            if (loginError)\n                loginError.textContent = error instanceof Error ? error.message : 'Login failed';\n        }\n    });\n    // Handle logout\n    logoutBtn?.addEventListener('click', async () => {\n        await storageService.clearAuth();\n        showLoggedOutState();\n    });\n    // Helper function to create auth headers for Supabase\n    async function createAuthHeaders() {\n        const authData = await storageService.getAuth();\n        const headers = {\n            'Content-Type': 'application/json',\n            'X-Client-Info': 'dsa-tracker-extension/1.0.0'\n        };\n        // Check for Supabase session data in different formats\n        if (authData?.token) {\n            headers['Authorization'] = `Bearer ${authData.token}`;\n        }\n        // Add all available cookies to increase chances of successful auth\n        if (authData?.sessionCookie) {\n            headers['Cookie'] = authData.sessionCookie;\n        }\n        return headers;\n    }\n    // Handle tracking problems\n    trackBtn?.addEventListener('click', async () => {\n        // First check if we're on a LeetCode problem page\n        chrome.tabs.query({ active: true, currentWindow: true }, async (tabs) => {\n            const tab = tabs[0];\n            if (!tab || !tab.id) {\n                setActionStatus('Error: Cannot access current tab');\n                return;\n            }\n            if (!tab.url?.includes('leetcode.com/problems/')) {\n                setActionStatus('Not on a LeetCode problem page');\n                return;\n            }\n            setActionStatus('Tracking problem...');\n            try {\n                // Get problem info from content script\n                const response = await new Promise((resolve) => {\n                    chrome.tabs.sendMessage(tab.id, { action: 'getProblemInfo' }, (response) => {\n                        // Handle case where content script doesn't respond\n                        if (!response) {\n                            console.error(\"DSA Tracker: No response from content script\");\n                            resolve({ error: \"Content script not responding - refresh the page\" });\n                            return;\n                        }\n                        resolve(response);\n                    });\n                    // Set a timeout in case the message never returns\n                    setTimeout(() => {\n                        resolve({ error: \"Content script timeout - refresh the page\" });\n                    }, 5000);\n                });\n                console.log(\"DSA Tracker: Response from content script\", response);\n                if (response.error) {\n                    setActionStatus(`Error: ${response.error}`);\n                    return;\n                }\n                if (!response.problem) {\n                    setActionStatus('Error: Could not get problem info');\n                    return;\n                }\n                const problem = response.problem;\n                const authData = await storageService.getAuth();\n                if (!authData) {\n                    setActionStatus('Error: Not logged in');\n                    return;\n                }\n                // Get authentication headers\n                const headers = await createAuthHeaders();\n                // Send to backend API\n                const requestBody = {\n                    title: problem.title,\n                    platformId: problem.leetcodeId,\n                    platform: 'LeetCode',\n                    difficulty: problem.difficulty !== 'Unknown' ? problem.difficulty : 'Medium',\n                    url: problem.url,\n                    status: 'Attempted',\n                    description: problem.description || null,\n                    examples: problem.examples || null,\n                    tags: problem.tags && problem.tags.length > 0 ? problem.tags.map(tag => ({\n                        name: tag,\n                        color: getTagColor(tag)\n                    })) : []\n                };\n                console.log(\"DSA Tracker: Sending problem to API:\", requestBody);\n                const apiResponse = await fetch(`${API_BASE_URL}/api/problems`, {\n                    method: 'POST',\n                    headers,\n                    credentials: 'include',\n                    body: JSON.stringify(requestBody)\n                });\n                const responseText = await apiResponse.text();\n                console.log(\"DSA Tracker: API response:\", apiResponse.status, responseText);\n                if (apiResponse.status === 401) {\n                    console.error(\"DSA Tracker: Authentication failed. Please try logging in again.\");\n                    setActionStatus('Authentication failed. Please log in again.');\n                    return;\n                }\n                let responseData;\n                try {\n                    responseData = JSON.parse(responseText);\n                }\n                catch (e) {\n                    console.error(\"DSA Tracker: Error parsing API response:\", e);\n                    responseData = { error: \"Invalid response format\" };\n                }\n                if (apiResponse.ok) {\n                    setActionStatus('Problem tracked successfully!');\n                    console.log(\"DSA Tracker: Problem tracked successfully:\", responseData);\n                    // Also save to local storage\n                    await storageService.addProblem({\n                        id: crypto.randomUUID(),\n                        title: problem.title,\n                        leetcodeId: problem.leetcodeId,\n                        difficulty: problem.difficulty,\n                        categories: [],\n                        url: problem.url,\n                        timestamp: problem.timestamp\n                    });\n                }\n                else {\n                    const isOnline = await storageService.getOnlineStatus();\n                    if (!isOnline) {\n                        // If offline, just store locally\n                        await storageService.addProblem({\n                            id: crypto.randomUUID(),\n                            title: problem.title,\n                            leetcodeId: problem.leetcodeId,\n                            difficulty: problem.difficulty,\n                            categories: [],\n                            url: problem.url,\n                            timestamp: problem.timestamp\n                        });\n                        setActionStatus('Offline: Problem saved locally');\n                    }\n                    else {\n                        // If online but API failed\n                        setActionStatus(`Error: ${responseData.error || 'Failed to track problem'}`);\n                    }\n                }\n            }\n            catch (error) {\n                console.error('Error tracking problem:', error);\n                setActionStatus('Error tracking problem');\n            }\n        });\n    });\n    // Handle error patterns button click\n    errorPatternsBtn?.addEventListener('click', async () => {\n        const authData = await storageService.getAuth();\n        if (!authData) {\n            setActionStatus('Error: Not logged in');\n            return;\n        }\n        // Store the token in localStorage for the error patterns page\n        localStorage.setItem('token', authData.token);\n        localStorage.setItem('apiBaseUrl', API_BASE_URL);\n        // Open the error patterns page\n        chrome.windows.create({\n            url: chrome.runtime.getURL('popup/error-patterns.html'),\n            type: 'popup',\n            width: 800,\n            height: 600\n        });\n    });\n    // Helper functions\n    function isTokenValid(authData) {\n        return Date.now() < authData.expiresAt;\n    }\n    function showLoggedInState(authData) {\n        if (loginSection)\n            loginSection.style.display = 'none';\n        if (problemSection)\n            problemSection.style.display = 'block';\n        if (logoutBtn)\n            logoutBtn.style.display = 'block';\n        if (connectionStatus) {\n            connectionStatus.textContent = 'Connected';\n            connectionStatus.classList.add('connected');\n        }\n        // Update UI with user info\n        const userName = authData.user.name || authData.user.email;\n        const userElement = document.getElementById('user-info');\n        if (userElement) {\n            userElement.textContent = `${userName}`;\n        }\n        // Try to get current problem info from active tab\n        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n            const tab = tabs[0];\n            if (tab.url?.includes('leetcode.com/problems/')) {\n                chrome.tabs.sendMessage(tab.id, { action: 'getProblemInfo' }, (response) => {\n                    if (response && response.problem) {\n                        updateProblemInfo(response.problem);\n                    }\n                });\n            }\n        });\n    }\n    function showLoggedOutState() {\n        if (loginSection)\n            loginSection.style.display = 'block';\n        if (problemSection)\n            problemSection.style.display = 'none';\n        if (logoutBtn)\n            logoutBtn.style.display = 'none';\n        if (connectionStatus) {\n            connectionStatus.textContent = 'Not connected';\n            connectionStatus.classList.remove('connected');\n        }\n    }\n    function updateProblemInfo(problem) {\n        const problemTitle = document.getElementById('problem-title');\n        const problemDifficulty = document.getElementById('problem-difficulty');\n        if (problemTitle) {\n            problemTitle.textContent = problem.title;\n        }\n        if (problemDifficulty) {\n            problemDifficulty.textContent = problem.difficulty;\n            problemDifficulty.className = 'difficulty ' + problem.difficulty.toLowerCase();\n        }\n    }\n    function setActionStatus(message) {\n        if (actionStatus) {\n            actionStatus.textContent = message;\n            // Clear after 3 seconds\n            setTimeout(() => {\n                if (actionStatus) {\n                    actionStatus.textContent = '';\n                }\n            }, 3000);\n        }\n    }\n    // Helper function to assign colors to tags\n    function getTagColor(tag) {\n        // Map of common problem categories to colors\n        const tagColors = {\n            'array': '#2196F3',\n            'string': '#4CAF50',\n            'hash-table': '#FFC107',\n            'math': '#9C27B0',\n            'dynamic-programming': '#FF5722',\n            'sorting': '#3F51B5',\n            'greedy': '#00BCD4',\n            'depth-first-search': '#795548',\n            'binary-search': '#607D8B',\n            'breadth-first-search': '#FF9800',\n            'tree': '#8BC34A',\n            'matrix': '#E91E63',\n            'two-pointers': '#673AB7',\n            'bit-manipulation': '#CDDC39',\n            'heap': '#009688',\n            'graph': '#FFEB3B',\n            'design': '#FF4081',\n            'simulation': '#03A9F4',\n            'prefix-sum': '#FF5252',\n            'stack': '#7986CB',\n            'queue': '#FF8A65',\n            'binary-tree': '#4DB6AC',\n            'recursion': '#BA68C8',\n            'linked-list': '#FFD54F'\n        };\n        // Normalize tag\n        const normalizedTag = tag.toLowerCase().replace(/\\s+/g, '-');\n        // Return color or a default\n        return tagColors[normalizedTag] ||\n            tagColors[Object.keys(tagColors).find(key => normalizedTag.includes(key)) || ''] ||\n            '#888888';\n    }\n});\n"],"names":[],"sourceRoot":""}