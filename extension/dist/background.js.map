{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://extension/./lib/storage.ts","webpack://extension/webpack/bootstrap","webpack://extension/webpack/runtime/define property getters","webpack://extension/webpack/runtime/hasOwnProperty shorthand","webpack://extension/webpack/runtime/make namespace object","webpack://extension/./background/background.ts"],"sourcesContent":["// Storage keys\nconst AUTH_KEY = 'dsa_tracker_auth';\n// @ts-expect-error - process.env.API_BASE_URL is injected by webpack.DefinePlugin\nconst API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';\n// Storage API wrapper\nclass StorageService {\n    // Auth methods\n    async saveAuth(authData) {\n        return chrome.storage.local.set({ [AUTH_KEY]: authData });\n    }\n    async getAuth() {\n        const result = await chrome.storage.local.get(AUTH_KEY);\n        return result[AUTH_KEY] || null;\n    }\n    async updateAuth(authData) {\n        const currentAuth = await this.getAuth();\n        if (!currentAuth)\n            return this.saveAuth(authData);\n        return this.saveAuth({\n            ...currentAuth,\n            ...authData\n        });\n    }\n    async clearAuth() {\n        return chrome.storage.local.remove(AUTH_KEY);\n    }\n    // Network status methods\n    async getOnlineStatus() {\n        try {\n            const response = await fetch('https://www.google.com', { method: 'HEAD', mode: 'no-cors' });\n            return response.type === 'opaque' || response.ok;\n        }\n        catch {\n            // Ignore error and return offline status\n            return false;\n        }\n    }\n    async setOnlineStatus(isOnline) {\n        // This is now just a no-op since we don't store this in local storage\n        console.log(`Online status set to: ${isOnline}`);\n    }\n    // Problem methods - Direct API communication\n    async getProblems() {\n        // Return empty array as we don't store locally anymore\n        return [];\n    }\n    async addProblem(problem) {\n        const authData = await this.getAuth();\n        if (!authData) {\n            console.error('Not authenticated, cannot add problem');\n            return;\n        }\n        try {\n            const isOnline = await this.getOnlineStatus();\n            if (!isOnline) {\n                console.log('Offline: Cannot add problem, no local storage available');\n                return;\n            }\n            // Send directly to API\n            await fetch(`${API_BASE_URL}/api/problems`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${authData.token}`\n                },\n                body: JSON.stringify(problem)\n            });\n        }\n        catch (error) {\n            console.error('Error adding problem:', error);\n        }\n    }\n    // Submission methods - Direct API communication\n    async getSubmissions() {\n        // Return empty array as we don't store locally anymore\n        return [];\n    }\n    async getPendingSubmissions() {\n        // Return empty array as we don't store locally anymore\n        return [];\n    }\n    async addSubmission(submission) {\n        const authData = await this.getAuth();\n        if (!authData) {\n            console.error('Not authenticated, cannot add submission');\n            return submission;\n        }\n        try {\n            const isOnline = await this.getOnlineStatus();\n            if (!isOnline) {\n                console.log('Offline: Cannot add submission, no local storage available');\n                return submission;\n            }\n            // Send directly to API\n            const response = await fetch(`${API_BASE_URL}/api/submissions`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${authData.token}`\n                },\n                body: JSON.stringify(submission)\n            });\n            if (response.ok) {\n                const result = await response.json();\n                return result;\n            }\n        }\n        catch (error) {\n            console.error('Error adding submission:', error);\n        }\n        return submission;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async updateSubmissionStatus(_id, _syncStatus) {\n        // No-op as we don't store locally anymore\n    }\n    // Error methods - Direct API communication\n    async getPendingErrors() {\n        // Return empty array as we don't store locally anymore\n        return [];\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async updateErrorStatus(_id, _status) {\n        // No-op as we don't store locally anymore\n    }\n    // Test case methods - Direct API communication\n    async getPendingTestCases() {\n        // Return empty array as we don't store locally anymore\n        return [];\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async updateTestCaseStatus(_id, _status) {\n        // No-op as we don't store locally anymore\n    }\n    // Bug report methods - Direct API communication\n    async getBugs() {\n        // Return empty array as we don't store locally anymore\n        return [];\n    }\n    // Sync timestamp methods\n    async updateSyncTimestamp() {\n        // No-op as we don't store locally anymore\n    }\n    // Helper method to clear all storage (only used for debugging/reset)\n    async clearAll() {\n        return chrome.storage.local.clear();\n    }\n}\n// Export singleton instance\nexport const storageService = new StorageService();\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Background script for the DSA Tracker extension\nimport { storageService } from '../lib/storage';\n// Connectivity check URL\nconst CONNECTIVITY_CHECK_URL = 'https://www.google.com';\n// API base URL\n// @ts-expect-error - process.env.API_BASE_URL is injected by webpack.DefinePlugin\nconst API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';\n// Global variable to track online status\nlet onlineStatus = true; // Default to online, will be checked immediately\n// Listen for extension installation\nchrome.runtime.onInstalled.addListener(() => {\n    console.log('DSA Tracker extension installed');\n    // Initialize online status\n    checkConnectivity().then(isOnline => {\n        onlineStatus = isOnline;\n        storageService.setOnlineStatus(isOnline);\n    });\n    // Set up periodic sync check\n    setInterval(syncData, SYNC_INTERVAL);\n    // Set up connectivity check\n    setInterval(checkConnectivity, CONNECTIVITY_CHECK_INTERVAL);\n});\n// Sync data periodically\nconst SYNC_INTERVAL = 15 * 60 * 1000; // 15 minutes\nconst CONNECTIVITY_CHECK_INTERVAL = 30 * 1000; // 30 seconds\nasync function syncData() {\n    const authData = await storageService.getAuth();\n    // Only sync if user is logged in and online\n    if (!authData || !onlineStatus)\n        return;\n    try {\n        console.log('Starting sync process...');\n        // Sync problems\n        const problems = await storageService.getProblems();\n        if (problems.length > 0) {\n            console.log(`Syncing ${problems.length} problems...`);\n            const response = await fetch(`${API_BASE_URL}/api/extension/sync`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${authData.token}`\n                },\n                body: JSON.stringify({ problems })\n            });\n            if (response.ok) {\n                await storageService.updateSyncTimestamp();\n                console.log('Problems synced successfully');\n            }\n        }\n        // Sync submissions\n        const pendingSubmissions = await storageService.getPendingSubmissions();\n        if (pendingSubmissions.length > 0) {\n            console.log(`Syncing ${pendingSubmissions.length} pending submissions...`);\n            try {\n                const response = await fetch(`${API_BASE_URL}/api/submissions/batch`, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': `Bearer ${authData.token}`\n                    },\n                    body: JSON.stringify({ submissions: pendingSubmissions })\n                });\n                if (response.ok) {\n                    const result = await response.json();\n                    console.log('Submissions sync result:', result);\n                    // Mark submissions as synced\n                    for (const submission of pendingSubmissions) {\n                        await storageService.updateSubmissionStatus(submission.id, 'synced');\n                    }\n                    console.log('Submissions synced successfully');\n                }\n                else {\n                    console.error('Failed to sync submissions:', await response.text());\n                }\n            }\n            catch (error) {\n                console.error('Error syncing submissions:', error);\n            }\n        }\n        // Sync error data\n        const pendingErrors = await storageService.getPendingErrors();\n        if (pendingErrors.length > 0) {\n            console.log(`Syncing ${pendingErrors.length} pending errors...`);\n            const response = await fetch(`${API_BASE_URL}/api/errors/submit/batch`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${authData.token}`\n                },\n                body: JSON.stringify({ errors: pendingErrors })\n            });\n            if (response.ok) {\n                // Mark synced errors\n                const syncedIds = await response.json();\n                for (const id of syncedIds.errorIds) {\n                    await storageService.updateErrorStatus(id, 'synced');\n                }\n                console.log('Errors synced successfully');\n            }\n        }\n        // Sync test cases\n        const pendingTestCases = await storageService.getPendingTestCases();\n        if (pendingTestCases.length > 0) {\n            console.log(`Syncing ${pendingTestCases.length} pending test cases...`);\n            const response = await fetch(`${API_BASE_URL}/api/testcases/batch`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${authData.token}`\n                },\n                body: JSON.stringify({ testCases: pendingTestCases })\n            });\n            if (response.ok) {\n                // Mark synced test cases\n                const syncedIds = await response.json();\n                for (const id of syncedIds.testCaseIds) {\n                    await storageService.updateTestCaseStatus(id, 'synced');\n                }\n                console.log('Test cases synced successfully');\n            }\n        }\n        // Sync bug reports\n        const bugs = await storageService.getBugs();\n        if (bugs.length > 0) {\n            console.log(`Syncing ${bugs.length} bug reports...`);\n            await fetch(`${API_BASE_URL}/api/extension/bugs`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${authData.token}`\n                },\n                body: JSON.stringify({ bugs })\n            });\n            console.log('Bug reports synced successfully');\n        }\n        console.log('Sync completed successfully');\n    }\n    catch (error) {\n        console.error('Sync failed:', error);\n    }\n}\n/**\n * Check if we're online\n */\nasync function checkConnectivity() {\n    try {\n        await fetch(CONNECTIVITY_CHECK_URL, {\n            method: 'HEAD',\n            mode: 'no-cors',\n            cache: 'no-store',\n        });\n        const newStatus = true;\n        if (onlineStatus !== newStatus) {\n            onlineStatus = newStatus;\n            storageService.setOnlineStatus(newStatus);\n            // If we just came online, try to sync\n            if (newStatus) {\n                syncData();\n            }\n        }\n        return true;\n    }\n    catch (_) {\n        void _; // Use the parameter to avoid linter error\n        const newStatus = false;\n        if (onlineStatus !== newStatus) {\n            onlineStatus = newStatus;\n            storageService.setOnlineStatus(newStatus);\n        }\n        return false;\n    }\n}\n/**\n * Creates headers with authentication information.\n * It will check for token expiry and attempt to refresh it if necessary.\n */\nasync function createAuthHeaders() {\n    let authData = await storageService.getAuth();\n    // If token is expired, try to refresh it.\n    // Add a buffer of 60 seconds to refresh before it actually expires\n    if (authData && Date.now() >= authData.expiresAt - 60000) {\n        console.log('DSA Tracker: Auth token is expiring or has expired, attempting refresh.');\n        const refreshed = await refreshSession();\n        if (refreshed) {\n            // Get the new auth data from storage\n            authData = await storageService.getAuth();\n        }\n        else {\n            console.log('DSA Tracker: Token refresh failed. User may need to log in again.');\n            // Clear auth data if refresh fails\n            authData = null;\n        }\n    }\n    const headers = {\n        'Content-Type': 'application/json',\n        'X-Client-Info': 'dsa-tracker-extension/1.0.0'\n    };\n    if (authData?.token) {\n        // Ensure token is properly formatted with Bearer prefix (case-sensitive)\n        headers['Authorization'] = `Bearer ${authData.token.trim()}`;\n        // Debug token to console\n        console.log(`DSA Tracker: Using auth token (first 10 chars): ${authData.token.substring(0, 10)}...`);\n        // Debug auth once in a while (don't do this on every request)\n        debugAuth(headers);\n    }\n    else {\n        console.log('DSA Tracker: No authentication token available');\n    }\n    // Always try to include cookies if they exist\n    const cookies = await getCookiesForDomain(new URL(API_BASE_URL).hostname);\n    if (cookies) {\n        headers['Cookie'] = cookies;\n    }\n    else if (authData?.sessionCookie) {\n        headers['Cookie'] = authData.sessionCookie;\n    }\n    return headers;\n}\n/**\n * Debug the authentication by testing against the debug endpoint\n */\nasync function debugAuth(headers) {\n    if (Math.random() > 0.2)\n        return; // Only debug ~20% of the time to avoid spam\n    try {\n        console.log('DSA Tracker: Testing authentication against debug endpoint');\n        const response = await fetch(`${API_BASE_URL}/api/auth/debug`, {\n            method: 'GET',\n            headers,\n            credentials: 'include'\n        });\n        if (response.ok) {\n            const data = await response.json();\n            console.log('DSA Tracker: Auth debug response:', data);\n            if (data.userFromToken) {\n                console.log(`DSA Tracker: Authentication SUCCESSFUL for user ${data.userFromToken.email}`);\n            }\n            else if (data.userFromCookie) {\n                console.log(`DSA Tracker: Cookie auth worked, but token auth failed for user ${data.userFromCookie.email}`);\n            }\n            else {\n                console.error('DSA Tracker: Authentication FAILED - no user found');\n            }\n        }\n        else {\n            console.error(`DSA Tracker: Auth debug request failed: ${response.status}`);\n        }\n    }\n    catch (error) {\n        console.error('DSA Tracker: Auth debug error:', error);\n    }\n}\n/**\n * Attempt to refresh the session using the refresh token.\n */\nasync function refreshSession() {\n    try {\n        const authData = await storageService.getAuth();\n        if (!authData?.refreshToken) {\n            console.log('DSA Tracker: No refresh token available.');\n            return false;\n        }\n        console.log('DSA Tracker: Attempting to refresh session with refresh token.');\n        // This endpoint should use the refresh_token to get a new session from Supabase\n        const response = await fetch(`${API_BASE_URL}/api/auth/refresh`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-Client-Info': 'dsa-tracker-extension/1.0.0'\n            },\n            body: JSON.stringify({\n                refreshToken: authData.refreshToken // Backend should expect this\n            }),\n            credentials: 'include'\n        });\n        if (response.ok) {\n            const newSession = await response.json();\n            if (newSession.token && newSession.user) {\n                // Assuming the refresh endpoint returns a full new AuthData-like object\n                const newAuthData = {\n                    token: newSession.token,\n                    refreshToken: newSession.refreshToken || authData.refreshToken,\n                    expiresAt: Date.now() + ((newSession.expiresIn || 3600) * 1000),\n                    user: newSession.user,\n                    sessionCookie: authData.sessionCookie // Preserve original cookie unless updated\n                };\n                await storageService.saveAuth(newAuthData);\n                // After saving, let's also update the cookie from the browser's storage\n                const cookies = await getCookiesForDomain(new URL(API_BASE_URL).hostname);\n                if (cookies) {\n                    await storageService.updateAuth({ sessionCookie: cookies });\n                }\n                console.log('DSA Tracker: Session refreshed and saved successfully.');\n                return true;\n            }\n            else {\n                console.error('DSA Tracker: Refresh endpoint response is missing required data.', newSession);\n                return false;\n            }\n        }\n        else {\n            const errorText = await response.text();\n            console.error('DSA Tracker: Failed to refresh session:', { status: response.status, error: errorText });\n            // If refresh fails (e.g. 401), we're likely logged out for good.\n            await storageService.clearAuth();\n        }\n        return false;\n    }\n    catch (error) {\n        console.error('DSA Tracker: Error during session refresh:', error);\n        return false;\n    }\n}\n/**\n * Get cookies for a specific domain\n */\nasync function getCookiesForDomain(domain) {\n    const cookies = [];\n    try {\n        // Note: this requires the \"cookies\" permission in manifest.json\n        const chromeCookies = await chrome.cookies.getAll({ domain });\n        for (const cookie of chromeCookies) {\n            cookies.push(`${cookie.name}=${cookie.value}`);\n        }\n        return cookies.join('; ');\n    }\n    catch (error) {\n        console.error('Error getting cookies:', error);\n        return '';\n    }\n}\n/**\n * Extract numeric ID from problem slug or title\n */\nfunction extractNumericId(problemId) {\n    // If it's already numeric, return as is\n    if (/^\\d+$/.test(problemId)) {\n        return problemId;\n    }\n    // Check if it's a URL or contains a numeric part\n    const urlMatch = problemId.match(/\\/problems\\/([^/]+)/);\n    if (urlMatch) {\n        problemId = urlMatch[1];\n    }\n    // If we can extract a numeric ID (like \"386-lexicographical-numbers\" -> \"386\")\n    const numericIdMatch = problemId.match(/^(\\d+)[-_]?/);\n    if (numericIdMatch) {\n        return numericIdMatch[1];\n    }\n    // If problem ID contains \"lexicographical-numbers\", map to \"386\"\n    if (problemId.includes('lexicographical-numbers')) {\n        return '386';\n    }\n    // Otherwise, return the original ID\n    return problemId;\n}\n/**\n * Get the current active tab\n */\nasync function getCurrentTab() {\n    const queryOptions = { active: true, currentWindow: true };\n    const [tab] = await chrome.tabs.query(queryOptions);\n    return tab;\n}\n/**\n * Handle code run data (no-op since we're not tracking code runs)\n */\nasync function handleCodeRun(_data) {\n    void _data; // Acknowledge unused parameter\n    console.log('Code run tracking is disabled - ignoring code run');\n    // This is a no-op function since we're not tracking code runs anymore\n    return { success: true };\n}\n/**\n * Handle sending a submission to the backend\n */\nasync function handleSubmission(data) {\n    try {\n        if (!onlineStatus) {\n            console.log(\"DSA Tracker: Offline, storing submission locally\");\n            return { success: true, error: 'Offline mode - data stored locally' };\n        }\n        // Get auth headers\n        const headers = await createAuthHeaders();\n        if (!headers['Authorization']) {\n            console.log(\"DSA Tracker: No auth token, storing locally\");\n            return { success: true, error: 'Not logged in - data stored locally' };\n        }\n        // Ensure the problem exists, but don't worry if it doesn't - we'll create it at the API level\n        // We just need to get problem details for creating it if needed\n        let problemDetails = null;\n        const tab = await getCurrentTab();\n        if (tab && tab.id) {\n            try {\n                const response = await new Promise((resolve) => {\n                    chrome.tabs.sendMessage(tab.id, { action: 'getProblemInfo' }, (response) => {\n                        if (chrome.runtime.lastError) {\n                            console.error('Error getting problem info:', chrome.runtime.lastError);\n                            resolve({ success: false });\n                        }\n                        else {\n                            resolve(response);\n                        }\n                    });\n                });\n                if (response && response.success) {\n                    problemDetails = response.problem;\n                }\n            }\n            catch (err) {\n                console.error('Error getting problem details:', err);\n            }\n        }\n        // Prepare submission data for the API\n        const formattedId = extractNumericId(data.problemId);\n        const submissionData = {\n            problemId: formattedId,\n            leetcodeSubmissionId: data.externalId || `submission_${Date.now()}`,\n            code: data.code,\n            language: data.language,\n            status: data.status,\n            runtime: data.runtime,\n            memory: data.memory,\n            errorMessage: data.errorMessage,\n            // Include problem details for creation if needed\n            platformTitle: problemDetails?.title,\n            platformDifficulty: problemDetails?.difficulty,\n            platformUrl: problemDetails?.url,\n            platformDescription: problemDetails?.description,\n            platformTags: problemDetails?.tags // Include problem tags\n        };\n        // Send the submission to the API\n        console.log(\"DSA Tracker: Sending submission to API:\", {\n            problemId: submissionData.problemId,\n            status: submissionData.status,\n            includesProblemDetails: !!problemDetails\n        });\n        const response = await fetch(`${API_BASE_URL}/api/submissions/track`, {\n            method: 'POST',\n            headers,\n            credentials: 'include',\n            body: JSON.stringify(submissionData)\n        });\n        if (response.status === 401) {\n            console.error(\"DSA Tracker: Authentication failed submitting solution\");\n            return { success: false, error: 'Authentication failed' };\n        }\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"DSA Tracker: Failed to submit solution:\", errorText);\n            return { success: false, error: errorText };\n        }\n        const result = await response.json();\n        console.log(\"DSA Tracker: Submission sent successfully:\", {\n            submissionId: result.submission?.id,\n            isNew: result.isNew\n        });\n        return { success: true };\n    }\n    catch (error) {\n        console.error(\"DSA Tracker: Error sending submission:\", error);\n        return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n    }\n}\n// Handle messages from content scripts\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    console.log('Received message:', message.type);\n    // Handle accepted submissions from the fetch interceptor\n    if (message.type === 'ACCEPTED_SUBMISSION') {\n        console.log('Received accepted submission:', message.data);\n        // Get the page URL from the sender tab\n        const pageUrl = sender.tab?.url;\n        // Process the accepted submission\n        handleAcceptedSubmission(message.data, pageUrl)\n            .then(() => {\n            sendResponse({ success: true });\n        })\n            .catch(error => {\n            console.error('Error handling accepted submission:', error);\n            sendResponse({ success: false, error: error.message });\n        });\n        return true; // Keep the message channel open for async response\n    }\n    // Handle other message types\n    if (message.action === 'sendSubmission') {\n        handleSubmission(message.data)\n            .then(result => {\n            sendResponse(result);\n        })\n            .catch(error => {\n            sendResponse({ success: false, error: error.message });\n        });\n        return true; // Keep the message channel open for async response\n    }\n    if (message.action === 'sendCodeRun') {\n        handleCodeRun(message.data)\n            .then(result => {\n            sendResponse(result);\n        })\n            .catch(error => {\n            sendResponse({ success: false, error: error.message });\n        });\n        return true; // Keep the message channel open for async response\n    }\n    return false; // For synchronous responses\n});\n/**\n * Handle an accepted submission from the content script\n * @param submissionData The data from the accepted submission\n * @param pageUrl The URL of the page where the submission was made\n */\nasync function handleAcceptedSubmission(submissionData, pageUrl) {\n    try {\n        console.log('Processing accepted submission:', submissionData);\n        if (!pageUrl) {\n            console.error('No URL provided for submission');\n            return;\n        }\n        // Extract problem slug from URL\n        const problemSlug = extractProblemSlugFromUrl(pageUrl);\n        if (!problemSlug) {\n            console.error('Could not extract problem slug from URL:', pageUrl);\n            return;\n        }\n        console.log(`Processing accepted submission for problem: ${problemSlug}`);\n        // Store the submission in local storage\n        const submissionRecordId = crypto.randomUUID();\n        await storageService.addSubmission({\n            id: submissionRecordId,\n            problemId: problemSlug,\n            submissionId: submissionData.submissionId,\n            code: submissionData.code || '',\n            language: submissionData.lang || 'unknown',\n            status: 'Accepted',\n            runtime: submissionData.runtime,\n            memory: submissionData.memory,\n            timestamp: submissionData.timestamp,\n            syncStatus: 'pending'\n        });\n        console.log('Submission stored in local storage with internal ID:', submissionRecordId);\n        // Prepare data for API call\n        const apiData = {\n            problemId: problemSlug,\n            code: submissionData.code || '',\n            language: submissionData.lang || 'unknown',\n            status: 'Accepted',\n            runtime: submissionData.runtime,\n            memory: submissionData.memory,\n            externalId: submissionData.submissionId,\n        };\n        // Attempt to send via the standard handler\n        if (onlineStatus) {\n            const result = await handleSubmission(apiData);\n            if (result.success) {\n                console.log('Submission sent successfully via handleSubmission');\n                await storageService.updateSubmissionStatus(submissionRecordId, 'synced');\n            }\n            else {\n                console.log('Submission API call failed, will retry on next sync:', result.error);\n            }\n        }\n        else {\n            console.log('Offline - submission will be synced later');\n        }\n        console.log('Finished processing accepted submission');\n    }\n    catch (error) {\n        console.error('Error processing accepted submission:', error);\n        throw error;\n    }\n}\n/**\n * Extract the problem slug from a LeetCode URL\n */\nfunction extractProblemSlugFromUrl(url) {\n    const match = url.match(/\\/problems\\/([^/]+)/);\n    return match ? match[1] : null;\n}\n// Listen for tab updates to initialize tracking on LeetCode problem pages\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n    // Only run when the page is fully loaded\n    if (changeInfo.status === 'complete' && tab.url && tab.url.includes('leetcode.com/problems/')) {\n        console.log(`DSA Tracker: Detected LeetCode problem page load: ${tab.url}`);\n        // Initialize tracking in the content script\n        chrome.tabs.sendMessage(tabId, { action: 'initializeTracking' }, (response) => {\n            if (chrome.runtime.lastError) {\n                console.error('DSA Tracker: Error initializing tracking:', chrome.runtime.lastError);\n            }\n            else if (response && response.success) {\n                console.log('DSA Tracker: Tracking initialized successfully');\n            }\n        });\n    }\n});\n// Add listeners for Monaco editor access\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    if (request.action === 'detect-monaco') {\n        detectMonacoInPage(sender.tab?.id).then(result => {\n            sendResponse(result);\n        });\n        return true; // Keep the message channel open for async response\n    }\n    if (request.action === 'get-monaco-code') {\n        getMonacoCodeFromPage(request.tabId || sender.tab?.id).then(result => {\n            sendResponse({\n                code: result.code,\n                error: result.error,\n                source: result.source\n            });\n        });\n        return true; // Keep the message channel open for async response\n    }\n    if (request.action === 'get-tab-id') {\n        sendResponse({ tabId: sender.tab?.id });\n        return true;\n    }\n    // Remove duplicate handlers for sendCodeRun and sendSubmission\n    // These are already handled in the first message listener\n    return false; // For unhandled messages\n});\n// Listen for long-lived connections from content script\nchrome.runtime.onConnect.addListener((port) => {\n    if (port.name === \"monaco-access\") {\n        console.log(\"DSA Tracker: Established connection with tab for Monaco access\");\n        // Listen for messages on this port\n        port.onMessage.addListener(async (message) => {\n            if (message.action === 'detect-monaco') {\n                const result = await detectMonacoInPage(port.sender?.tab?.id);\n                port.postMessage({ action: 'monaco-detected', found: result.found });\n            }\n            if (message.action === 'get-monaco-code') {\n                const result = await getMonacoCodeFromPage(port.sender?.tab?.id);\n                port.postMessage({\n                    action: 'monaco-code',\n                    code: result.code,\n                    source: result.source,\n                    error: result.error\n                });\n            }\n        });\n        // Handle disconnection\n        port.onDisconnect.addListener(() => {\n            console.log(\"DSA Tracker: Connection with tab closed\");\n        });\n    }\n});\n// Function to detect Monaco editor in a page using chrome.scripting\nasync function detectMonacoInPage(tabId) {\n    if (!tabId) {\n        console.error(\"DSA Tracker: No tab ID provided for Monaco detection\");\n        return { found: false };\n    }\n    try {\n        // Execute the detection script in the page context\n        const results = await chrome.scripting.executeScript({\n            target: { tabId },\n            world: 'MAIN',\n            func: () => {\n                // This function runs in the page context\n                try {\n                    // Cast window to our custom type\n                    const win = window;\n                    // Properly check for monaco in the window object\n                    const hasMonaco = 'monaco' in window &&\n                        win.monaco !== undefined &&\n                        win.monaco !== null;\n                    // Check if the monaco object has the editor property\n                    const hasEditor = hasMonaco &&\n                        win.monaco && 'editor' in win.monaco &&\n                        win.monaco.editor !== undefined;\n                    // Check if the editor has the getEditors method\n                    const hasGetEditors = hasEditor &&\n                        win.monaco?.editor && 'getEditors' in win.monaco.editor &&\n                        typeof win.monaco.editor.getEditors === 'function';\n                    // Try to actually call getEditors to verify it works\n                    let editorsExist = false;\n                    if (hasGetEditors && win.monaco?.editor?.getEditors) {\n                        try {\n                            const editors = win.monaco.editor.getEditors();\n                            editorsExist = Array.isArray(editors) && editors.length > 0;\n                        }\n                        catch (e) {\n                            console.error(\"Error calling getEditors:\", e);\n                        }\n                    }\n                    return {\n                        hasMonaco,\n                        hasEditor,\n                        hasGetEditors,\n                        editorsExist,\n                        isReady: hasMonaco && hasEditor && hasGetEditors\n                    };\n                }\n                catch (e) {\n                    console.error(\"Error in Monaco detection:\", e);\n                    return {\n                        hasMonaco: false,\n                        hasEditor: false,\n                        hasGetEditors: false,\n                        editorsExist: false,\n                        isReady: false,\n                        error: String(e)\n                    };\n                }\n            }\n        });\n        // Check the result\n        const result = results[0]?.result;\n        const found = result?.isReady || false;\n        // Log more detailed information\n        console.log(`DSA Tracker: Monaco detection in tab ${tabId}:`, result);\n        return { found };\n    }\n    catch (error) {\n        console.error(\"DSA Tracker: Error detecting Monaco editor:\", error);\n        return { found: false };\n    }\n}\n// Function to get code from Monaco editor in a page using chrome.scripting\nasync function getMonacoCodeFromPage(tabId) {\n    if (!tabId) {\n        console.error(\"DSA Tracker: No tab ID provided for getting Monaco code\");\n        return { code: null, error: \"No tab ID provided\" };\n    }\n    try {\n        // Execute the script to get code and editor information in the page context\n        const results = await chrome.scripting.executeScript({\n            target: { tabId },\n            world: 'MAIN',\n            func: () => {\n                // This function runs in the page context\n                try {\n                    // Cast window to our custom type\n                    const win = window;\n                    // Try to gather comprehensive information about the editor state\n                    const info = {\n                        hasMonaco: 'monaco' in window,\n                        hasEditor: 'monaco' in window && win.monaco && 'editor' in win.monaco,\n                        hasGetEditors: false,\n                        editorsCount: 0,\n                        editorIds: [],\n                        domEditorCount: document.querySelectorAll('.monaco-editor').length,\n                        editorModel: null,\n                        code: null,\n                        source: 'none',\n                        codeLength: 0,\n                        codePreview: '',\n                        attemptedMethods: []\n                    };\n                    // Only try the official Monaco API\n                    info.attemptedMethods.push('monaco-api');\n                    if (info.hasEditor && win.monaco?.editor) {\n                        try {\n                            info.hasGetEditors = typeof win.monaco.editor.getEditors === 'function';\n                            if (info.hasGetEditors && win.monaco.editor.getEditors) {\n                                const editors = win.monaco.editor.getEditors();\n                                info.editorsCount = editors.length;\n                                // Get IDs of all editors for debugging\n                                editors.forEach(editor => {\n                                    if (editor.getId) {\n                                        info.editorIds.push(editor.getId());\n                                    }\n                                });\n                                if (editors.length > 0) {\n                                    const editor = editors[0];\n                                    if (editor.getModel && typeof editor.getModel === 'function') {\n                                        const model = editor.getModel();\n                                        if (model) {\n                                            const modelInfo = {\n                                                id: typeof model.getId === 'function' ? model.getId() : undefined\n                                            };\n                                            // Try to access URI safely\n                                            try {\n                                                // We have to use any here since we don't know the structure of Monaco's model\n                                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                                const uri = model.uri;\n                                                if (uri && typeof uri.toString === 'function') {\n                                                    modelInfo.uri = uri.toString();\n                                                }\n                                            }\n                                            catch (err) {\n                                                void err; // Acknowledge unused variable\n                                            }\n                                            info.editorModel = modelInfo;\n                                        }\n                                    }\n                                    if (editor.getValue && typeof editor.getValue === 'function') {\n                                        info.code = editor.getValue();\n                                        info.source = 'monaco-api';\n                                        info.codeLength = info.code.length;\n                                        info.codePreview = info.code.substring(0, 100) + (info.code.length > 100 ? '...' : '');\n                                        console.log(`[Page Context] Successfully retrieved code via Monaco API: ${info.codeLength} chars`);\n                                        return { code: info.code, info };\n                                    }\n                                }\n                            }\n                        }\n                        catch (e) {\n                            console.error(\"[Page Context] Error accessing Monaco API:\", e);\n                            info.attemptedMethods.push('monaco-api-failed');\n                        }\n                    }\n                    // If we got this far, we couldn't find any code\n                    console.log(`[Page Context] Failed to find code using Monaco API. Monaco available: ${info.hasMonaco}, Editor available: ${info.hasEditor}, GetEditors available: ${info.hasGetEditors}`);\n                    return {\n                        code: null,\n                        error: \"No code found using Monaco API\",\n                        info\n                    };\n                }\n                catch (e) {\n                    console.error(\"[Page Context] Error in code extraction:\", e);\n                    return {\n                        code: null,\n                        error: e instanceof Error ? e.message : String(e)\n                    };\n                }\n            }\n        });\n        // Check the result\n        const result = results[0]?.result;\n        const code = result?.code || null;\n        const error = result?.error;\n        const info = result?.info;\n        const source = info?.source || 'unknown';\n        if (code) {\n            console.log(`DSA Tracker: Got code from page in tab ${tabId}: ${code.length} chars, source: ${source}`);\n            console.log(`DSA Tracker: Code preview: ${code.substring(0, 100)}${code.length > 100 ? '...' : ''}`);\n            console.log(`DSA Tracker: Editor info:`, info);\n        }\n        else {\n            console.log(`DSA Tracker: Failed to get code from Monaco API in tab ${tabId}: ${error}`);\n            console.log(`DSA Tracker: Monaco info: available=${info?.hasMonaco}, editor=${info?.hasEditor}, getEditors=${info?.hasGetEditors}, editorCount=${info?.editorsCount}`);\n        }\n        return { code, error, source };\n    }\n    catch (error) {\n        const errorMsg = error instanceof Error ? error.message : String(error);\n        console.error(\"DSA Tracker: Error getting code from page:\", error);\n        return { code: null, error: errorMsg };\n    }\n}\n"],"names":[],"sourceRoot":""}