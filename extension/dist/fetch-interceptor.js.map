{"version":3,"file":"fetch-interceptor.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://extension/./content/injectScript.ts","webpack://extension/webpack/bootstrap","webpack://extension/webpack/runtime/define property getters","webpack://extension/webpack/runtime/hasOwnProperty shorthand","webpack://extension/webpack/runtime/make namespace object","webpack://extension/./content/fetch-interceptor.ts"],"sourcesContent":["/**\n * This file is responsible for injecting the fetch interceptor script into the page context.\n * Since the content script runs in an isolated world, we need to inject a script tag\n * to access and modify objects in the page's JavaScript context.\n */\n// The script to be injected as a string - this will run in the page context\nconst fetchInterceptorScript = `\r\n(function() {\r\n  // Store the original fetch function\r\n  const originalFetch = window.fetch;\r\n  console.log('[DSA Tracker Injected] Fetch interceptor installed');\r\n\r\n  // Add a debug function to show visible notifications for debugging\r\n  function showDebugNotification(message, type = 'info') {\r\n    try {\r\n      // Create notification element if it doesn't exist\r\n      let container = document.getElementById('dsa-tracker-debug-container');\r\n      if (!container) {\r\n        container = document.createElement('div');\r\n        container.id = 'dsa-tracker-debug-container';\r\n        container.style.position = 'fixed';\r\n        container.style.bottom = '10px';\r\n        container.style.right = '10px';\r\n        container.style.zIndex = '10000';\r\n        container.style.maxWidth = '300px';\r\n        container.style.maxHeight = '400px';\r\n        container.style.overflow = 'auto';\r\n        document.body.appendChild(container);\r\n      }\r\n      \r\n      // Create notification\r\n      const notification = document.createElement('div');\r\n      notification.style.padding = '10px';\r\n      notification.style.margin = '5px';\r\n      notification.style.borderRadius = '5px';\r\n      notification.style.fontSize = '12px';\r\n      notification.style.fontFamily = 'monospace';\r\n      notification.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';\r\n      notification.style.opacity = '0.9';\r\n      \r\n      // Set color based on type\r\n      if (type === 'error') {\r\n        notification.style.backgroundColor = '#ffcccc';\r\n        notification.style.color = '#990000';\r\n      } else if (type === 'success') {\r\n        notification.style.backgroundColor = '#ccffcc';\r\n        notification.style.color = '#006600';\r\n      } else {\r\n        notification.style.backgroundColor = '#e6f7ff';\r\n        notification.style.color = '#0066cc';\r\n      }\r\n      \r\n      // Add timestamp and message\r\n      notification.textContent = \\`[\\${new Date().toLocaleTimeString()}] \\${message}\\`;\r\n      \r\n      // Add to container\r\n      container.appendChild(notification);\r\n      \r\n      // Remove after 10 seconds\r\n      setTimeout(() => {\r\n        if (notification.parentNode) {\r\n          notification.parentNode.removeChild(notification);\r\n        }\r\n      }, 10000);\r\n    } catch (e) {\r\n      // Ignore errors in debug function\r\n      console.error('Error in debug notification:', e);\r\n    }\r\n  }\r\n\r\n  // Replace window.fetch with our patched version\r\n  window.fetch = async function(...args) {\r\n    const [url, options] = args;\r\n    \r\n    // More verbose logging for debugging submission detection\r\n    if (typeof url === 'string') {\r\n      // Enhanced pattern matching for submission requests\r\n      const submissionPatterns = [\r\n        /\\\\/submit\\\\b/,\r\n        /\\\\/submissions\\\\//,\r\n        /\\\\/problems\\\\/[^/]+\\\\/submit/,\r\n        /graphql/\r\n      ];\r\n      \r\n      const isSubmit = submissionPatterns.some(pattern => pattern.test(url)) && \r\n                      options?.method === 'POST';\r\n      \r\n      if (isSubmit) {\r\n        console.log('[DSA Tracker Injected] Potential submission request detected:', {\r\n          url,\r\n          method: options?.method,\r\n          hasBody: !!options?.body\r\n        });\r\n        \r\n        showDebugNotification('Potential submission request detected: ' + url.substring(0, 50), 'info');\r\n        \r\n        // Log the body for debugging if present\r\n        if (options?.body) {\r\n          try {\r\n            const bodyContent = typeof options.body === 'string' \r\n              ? options.body \r\n              : options.body instanceof FormData \r\n                ? 'FormData object (cannot stringify)' \r\n                : JSON.stringify(options.body);\r\n            console.log('[DSA Tracker Injected] Request body:', bodyContent.substring(0, 200) + (bodyContent.length > 200 ? '...' : ''));\r\n            \r\n            // Check for GraphQL submission\r\n            if (url.includes('graphql') && typeof options.body === 'string') {\r\n              try {\r\n                const parsed = JSON.parse(options.body);\r\n                if (parsed.operationName && \r\n                   (parsed.operationName === 'submitCode' || \r\n                    parsed.operationName === 'submitSolution' || \r\n                    parsed.operationName.includes('submission'))) {\r\n                  console.log('[DSA Tracker Injected] GraphQL submission detected:', parsed.operationName);\r\n                  showDebugNotification('GraphQL submission detected: ' + parsed.operationName, 'info');\r\n                }\r\n              } catch (e) {\r\n                console.log('[DSA Tracker Injected] Failed to parse GraphQL body');\r\n              }\r\n            }\r\n          } catch (e) {\r\n            console.log('[DSA Tracker Injected] Could not log body');\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Check if this is a submission request with improved pattern matching\r\n    if (typeof url === 'string' && \r\n        ((url.includes('/problems/') && url.includes('/submit')) || \r\n         url.includes('/submissions/') || \r\n         (url.includes('graphql') && options?.body && \r\n          (typeof options.body === 'string' && \r\n           (options.body.includes('submitCode') || options.body.includes('submitSolution')))))) {\r\n      try {\r\n        // Generate a unique ID for this submission\r\n        const submissionTime = Date.now();\r\n        const submissionId = submissionTime + '-' + Math.random().toString(36).substring(2, 9);\r\n        \r\n        showDebugNotification('Processing submission request...', 'info');\r\n        \r\n        // Extract code and language from the request body\r\n        const body = options.body;\r\n        let lang, code, questionId;\r\n        \r\n        if (body instanceof FormData) {\r\n          lang = body.get('lang');\r\n          code = body.get('typed_code');\r\n          questionId = body.get('question_id');\r\n          console.log('[DSA Tracker Injected] Extracted from FormData:', { lang, codeLength: code?.length });\r\n        } else if (typeof body === 'string') {\r\n          try {\r\n            // Try URL encoded form data\r\n            if (body.includes('=') && body.includes('&')) {\r\n              const parsed = new URLSearchParams(body);\r\n              lang = parsed.get('lang');\r\n              code = parsed.get('typed_code') || parsed.get('code');\r\n              questionId = parsed.get('question_id') || parsed.get('questionId');\r\n              console.log('[DSA Tracker Injected] Extracted from URLSearchParams:', { lang, codeLength: code?.length });\r\n            } \r\n            // Try JSON format\r\n            else {\r\n              try {\r\n                const parsed = JSON.parse(body);\r\n                \r\n                // Handle GraphQL submissions\r\n                if (parsed.operationName && \r\n                   (parsed.operationName === 'submitCode' || \r\n                    parsed.operationName === 'submitSolution')) {\r\n                  const variables = parsed.variables || {};\r\n                  lang = variables.lang || variables.languageSlug;\r\n                  code = variables.code || variables.sourceCode || variables.typedCode;\r\n                  questionId = variables.questionId || variables.titleSlug;\r\n                  console.log('[DSA Tracker Injected] Extracted from GraphQL:', { lang, codeLength: code?.length });\r\n                } \r\n                // Handle regular JSON submissions\r\n                else {\r\n                  lang = parsed.lang || parsed.language;\r\n                  code = parsed.typed_code || parsed.submission_code || parsed.code || parsed.sourceCode;\r\n                  questionId = parsed.question_id || parsed.questionId || parsed.titleSlug;\r\n                  console.log('[DSA Tracker Injected] Extracted from JSON:', { lang, codeLength: code?.length });\r\n                }\r\n              } catch (_) {\r\n                // Not a format we recognize\r\n                console.log('[DSA Tracker Injected] Could not extract data from body');\r\n              }\r\n            }\r\n          } catch (_) {\r\n            // Not a format we recognize\r\n            console.log('[DSA Tracker Injected] Could not extract data from body');\r\n          }\r\n        }\r\n        \r\n        // If we couldn't extract the code, try to get it from the Monaco editor\r\n        if (!code && window.monaco && window.monaco.editor) {\r\n          try {\r\n            const editors = window.monaco.editor.getEditors();\r\n            if (editors && editors.length > 0) {\r\n              code = editors[0].getValue();\r\n              console.log('[DSA Tracker Injected] Got code from Monaco editor:', { codeLength: code.length });\r\n            }\r\n          } catch (e) {\r\n            console.log('[DSA Tracker Injected] Failed to get code from Monaco editor');\r\n          }\r\n        }\r\n        \r\n        // Call the original fetch\r\n        const response = await originalFetch.apply(this, args);\r\n        \r\n        // Clone the response so we can read it without consuming it\r\n        const clonedResponse = response.clone();\r\n        \r\n        // Parse the response to get the submission_id\r\n        try {\r\n          const responseData = await clonedResponse.json();\r\n          console.log('[DSA Tracker Injected] Submission response:', responseData);\r\n          \r\n          // Extract submission ID from various response formats\r\n          let extractedSubmissionId = null;\r\n          \r\n          if (responseData.submission_id) {\r\n            extractedSubmissionId = responseData.submission_id;\r\n          } else if (responseData.submissionId) {\r\n            extractedSubmissionId = responseData.submissionId;\r\n          } else if (responseData.data && responseData.data.submitCode) {\r\n            extractedSubmissionId = responseData.data.submitCode.id || responseData.data.submitCode.submissionId;\r\n          } else if (responseData.data && responseData.data.submitSolution) {\r\n            extractedSubmissionId = responseData.data.submitSolution.id || responseData.data.submitSolution.submissionId;\r\n          } else if (responseData.interpret_id) {\r\n            extractedSubmissionId = responseData.interpret_id;\r\n          }\r\n          \r\n          if (extractedSubmissionId) {\r\n            // Store submission data for later correlation\r\n            window.__DSA_TRACKER_SUBMISSIONS = window.__DSA_TRACKER_SUBMISSIONS || {};\r\n            window.__DSA_TRACKER_SUBMISSIONS[extractedSubmissionId] = {\r\n              submissionId: extractedSubmissionId,\r\n              trackerId: submissionId,\r\n              code,\r\n              lang,\r\n              questionId,\r\n              timestamp: submissionTime,\r\n              status: 'pending'\r\n            };\r\n            \r\n            console.log('[DSA Tracker Injected] Submission detected:', extractedSubmissionId);\r\n            showDebugNotification('Submission detected: ' + extractedSubmissionId, 'success');\r\n          }\r\n        } catch (error) {\r\n          console.error('[DSA Tracker Injected] Error parsing submission response:', error);\r\n          showDebugNotification('Error parsing submission response: ' + error.message, 'error');\r\n        }\r\n        \r\n        return response;\r\n      } catch (error) {\r\n        console.error('[DSA Tracker Injected] Error intercepting submission:', error);\r\n        showDebugNotification('Error intercepting submission: ' + error.message, 'error');\r\n        // Fall back to original fetch if our interception fails\r\n        return originalFetch.apply(this, args);\r\n      }\r\n    } \r\n    // Check if this is a submission status check request with improved pattern matching\r\n    else if (typeof url === 'string' && \r\n            (url.match(/\\\\/submissions\\\\/detail\\\\/\\\\d+\\\\/check/) || \r\n             url.match(/\\\\/submissions\\\\/\\\\d+/) ||\r\n             url.match(/\\\\/check\\\\/\\\\d+/) ||\r\n             url.match(/submission[_-]?id=\\\\d+/) ||\r\n             url.includes('check_submission') ||\r\n             (url.includes('graphql') && options?.body && \r\n              typeof options.body === 'string' && options.body.includes('submissionDetails')))) {\r\n      try {\r\n        // Extract submission ID from URL or body\r\n        let submissionId = null;\r\n        \r\n        // Try to extract from URL first\r\n        const urlMatches = url.match(/\\\\/submissions\\\\/detail\\\\/(\\\\d+)\\\\/check/) || \r\n                          url.match(/\\\\/submissions\\\\/(\\\\d+)/) ||\r\n                          url.match(/\\\\/check\\\\/(\\\\d+)/) ||\r\n                          url.match(/submission[_-]?id=(\\\\d+)/);\r\n                        \r\n        if (urlMatches && urlMatches[1]) {\r\n          submissionId = urlMatches[1];\r\n        }\r\n        // If not found in URL, try to extract from body for GraphQL requests\r\n        else if (url.includes('graphql') && options?.body && typeof options.body === 'string') {\r\n          try {\r\n            const parsed = JSON.parse(options.body);\r\n            if (parsed.variables && parsed.variables.submissionId) {\r\n              submissionId = parsed.variables.submissionId;\r\n            }\r\n          } catch (_) {\r\n            // Ignore parsing errors\r\n          }\r\n        }\r\n        \r\n        if (submissionId) {\r\n          console.log('[DSA Tracker Injected] Checking submission status for:', submissionId);\r\n          showDebugNotification('Checking submission status: ' + submissionId, 'info');\r\n          \r\n          // Call the original fetch\r\n          const response = await originalFetch.apply(this, args);\r\n          \r\n          // Clone the response so we can read it without consuming it\r\n          const clonedResponse = response.clone();\r\n          \r\n          try {\r\n            // Parse the response to check the status\r\n            const responseData = await clonedResponse.json();\r\n            console.log('[DSA Tracker Injected] Status check response:', responseData);\r\n            \r\n            // Check various status fields that might indicate acceptance\r\n            let isAccepted = false;\r\n            \r\n            // Handle different response formats\r\n            if (responseData.status_msg === \"Accepted\" || responseData.statusDisplay === \"Accepted\") {\r\n              isAccepted = true;\r\n            } else if (responseData.status_code === 10 || responseData.statusCode === 10) {\r\n              isAccepted = true;\r\n            } else if (responseData.state === \"SUCCESS\" || responseData.judgeResult === \"SUCCESS\") {\r\n              isAccepted = true;\r\n            } else if (responseData.status === \"Accepted\") {\r\n              isAccepted = true;\r\n            } else if (responseData.data && responseData.data.submissionDetails) {\r\n              const details = responseData.data.submissionDetails;\r\n              isAccepted = details.status === \"Accepted\" || \r\n                          details.statusDisplay === \"Accepted\" ||\r\n                          details.statusCode === 10;\r\n            }\r\n            \r\n            // If this is a final result and the submission was accepted\r\n            if (responseData && \r\n                isAccepted && \r\n                window.__DSA_TRACKER_SUBMISSIONS && \r\n                window.__DSA_TRACKER_SUBMISSIONS[submissionId]) {\r\n              \r\n              // Get the stored submission data\r\n              const submissionData = window.__DSA_TRACKER_SUBMISSIONS[submissionId];\r\n              submissionData.status = 'accepted';\r\n              \r\n              console.log('[DSA Tracker Injected] ACCEPTED submission detected:', submissionId);\r\n              showDebugNotification('ACCEPTED submission detected: ' + submissionId, 'success');\r\n              \r\n              // Extract runtime and memory from different response formats\r\n              let runtime = null;\r\n              let memory = null;\r\n              \r\n              if (responseData.status_runtime) {\r\n                runtime = responseData.status_runtime;\r\n              } else if (responseData.runtime) {\r\n                runtime = responseData.runtime;\r\n              } else if (responseData.data && responseData.data.submissionDetails) {\r\n                runtime = responseData.data.submissionDetails.runtime;\r\n                memory = responseData.data.submissionDetails.memory;\r\n              }\r\n              \r\n              if (responseData.status_memory) {\r\n                memory = responseData.status_memory;\r\n              } else if (responseData.memory) {\r\n                memory = responseData.memory;\r\n              }\r\n              \r\n              // Notify our extension via a custom event\r\n              window.dispatchEvent(new CustomEvent('DSA_TRACKER_SUBMISSION_ACCEPTED', {\r\n                detail: {\r\n                  submissionId,\r\n                  trackerId: submissionData.trackerId,\r\n                  code: submissionData.code,\r\n                  lang: submissionData.lang,\r\n                  questionId: submissionData.questionId,\r\n                  runtime: runtime,\r\n                  memory: memory,\r\n                  timestamp: submissionData.timestamp\r\n                }\r\n              }));\r\n              \r\n              // Clean up after successful detection\r\n              delete window.__DSA_TRACKER_SUBMISSIONS[submissionId];\r\n            }\r\n          } catch (error) {\r\n            console.error('[DSA Tracker Injected] Error parsing status check response:', error);\r\n            showDebugNotification('Error parsing status check: ' + error.message, 'error');\r\n          }\r\n          \r\n          return response;\r\n        }\r\n      } catch (error) {\r\n        console.error('[DSA Tracker Injected] Error intercepting status check:', error);\r\n        showDebugNotification('Error intercepting status check: ' + error.message, 'error');\r\n      }\r\n    }\r\n    \r\n    // For all other requests, just use the original fetch\r\n    return originalFetch.apply(this, args);\r\n  };\r\n  \r\n  // Clean up old submissions after 5 minutes\r\n  setInterval(() => {\r\n    if (window.__DSA_TRACKER_SUBMISSIONS) {\r\n      const now = Date.now();\r\n      Object.keys(window.__DSA_TRACKER_SUBMISSIONS).forEach(id => {\r\n        const submission = window.__DSA_TRACKER_SUBMISSIONS[id];\r\n        if (now - submission.timestamp > 5 * 60 * 1000) {\r\n          delete window.__DSA_TRACKER_SUBMISSIONS[id];\r\n        }\r\n      });\r\n    }\r\n  }, 60 * 1000); // Check every minute\r\n  \r\n  console.log('[DSA Tracker Injected] Fetch interceptor installed and ready');\r\n  showDebugNotification('DSA Tracker fetch interceptor installed and ready', 'success');\r\n})();\r\n`;\n// Reference fetchInterceptorScript to avoid linter 'assigned but never used'\nvoid fetchInterceptorScript;\n/**\n * Injects the fetch interceptor script into the page context\n */\nexport function injectFetchInterceptor() {\n    try {\n        // Create a script element pointing to our external interceptor bundle\n        const scriptElement = document.createElement('script');\n        scriptElement.src = chrome.runtime.getURL('pageFetchInterceptor.js');\n        scriptElement.type = 'text/javascript';\n        // Append to page\n        (document.head || document.documentElement).appendChild(scriptElement);\n        // Remove after loading\n        scriptElement.onload = () => scriptElement.remove();\n        console.log('[DSA Tracker] Injected external fetch interceptor');\n    }\n    catch (error) {\n        console.error('[DSA Tracker] Failed to inject external fetch interceptor:', error);\n    }\n}\n/**\n * Listen for the custom event from the injected script\n */\nexport function listenForAcceptedSubmissions(callback) {\n    console.log('[DSA Tracker] Setting up listener for accepted submissions');\n    window.addEventListener('DSA_TRACKER_SUBMISSION_ACCEPTED', ((event) => {\n        console.log('[DSA Tracker] Received accepted submission event:', event.detail);\n        callback(event.detail);\n    }));\n    console.log('[DSA Tracker] Listener for accepted submissions set up');\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * This is the entry point for the fetch interceptor content script.\n * It runs at document_start to ensure we can intercept network requests\n * before the page's JavaScript has a chance to make any.\n */\nimport { injectFetchInterceptor, listenForAcceptedSubmissions } from './injectScript';\n// Log that the fetch interceptor content script is running\nconsole.log('[DSA Tracker] Fetch interceptor content script loaded');\n// Inject the fetch interceptor as soon as possible\ninjectFetchInterceptor();\n// Listen for accepted submissions and send them to the background script\nlistenForAcceptedSubmissions((submissionData) => {\n    console.log('[DSA Tracker] Received accepted submission in content script:', submissionData);\n    // Send the accepted submission data to the background script\n    chrome.runtime.sendMessage({\n        type: 'ACCEPTED_SUBMISSION',\n        data: submissionData\n    }, response => {\n        if (chrome.runtime.lastError) {\n            console.error('[DSA Tracker] Error sending accepted submission to background:', chrome.runtime.lastError);\n        }\n        else {\n            console.log('[DSA Tracker] Background script response to accepted submission:', response);\n        }\n    });\n});\n"],"names":[],"sourceRoot":""}